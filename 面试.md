## HTML

### doctype

* 标准模式
* 怪异模式

用于告知浏览器使用哪种模式进行渲染。

### 语义化

概念：

* 正确的HTML嵌套结构，合理化的使用标签

意义：对人和机器都友好

* 对机器：
  * seo
  * 网页结构合理
* 对人：
  * 代码可读性强，便于维护
  * 对视障用户友好

如何判断：

* 去掉样式表

如何做到：

* 少用无意义的标签，例如div和span
* 不要使用样式标签去定义样式，例如h1去定义加粗样式

### meta标签

* charset属性
* 视口
* seo相关信息
* 兼容性处理
* ...

### iframe

优点：

* 可以做微前端
* 动态嵌入网页显示
* 跨域通信

缺点：

* seo问题，iframe动态嵌入的网页无法被搜索引擎收录
* 增加http请求
* 占用内存
* 会有一些安全性问题

### canvas

canvas和svg区别：

* 前者是通过js动态渲染的，后者是通过xml静态描述的
* 前者渲染的是位图，缩放会失真；后者是矢量图，不会失真
* 前者适合大数据量，通过js控制灵活性更高；后者适合移动端和小数据量，例如icon

* 没有谁更强大，要根据业务场景选择不同的技术

离屏渲染

* 通过js在内存中渲染后，再将创建的canvas元素插入到页面中

碰撞检测：

* 外接圆
* 外接矩形

图片操作：

* 获取像素数据：ctx.getImageData()
* 操作像素数据：循环
* 生成图片：ctx.putImageData()

导出图片：

* toDataURL：将canvas对象转为成base64形式

  ```js
  const cns = document.getElementById('canvas')
  
  const dataURL = cns.toDataURL
  const img = new Image()
  img.src = dataURL
  document.body.appendChild(img)
  ```

* toBlob：将canvas对象转换为二进制对象

  ```js
  cns.toBlob && cns.toBlob(blob => {
  	const url = URL.createObjectURL(blob);
  	const img = new Image();
  	img.src = url;
  
      img.onload = () => {
          URL.revokeObjectURL(url);
      };
  
      document.body.appendChild(img);
  });
  ```

## CSS

### bem规范

概念：

* 一种css命名规范，让你的css变得结构化和可重用

### 引入方式

* 内联
* 外联
* 行内
* 导入

### 特性

#### 继承性

能继承的属性：

* 文本属性：font-size，font-weight，font-family等
* 列表属性：list-style
* color：注意a标签的color属性

#### 层叠性

优先级高的会层叠优先级低的样式。

优先级比较：

* import：无穷
* 行内：1000
* id：100
* class：10
* 标签：1
* 通配符：0
* 继承：0
* 浏览器默认

若优先级相同，后出现的会层叠之前的样式。

### 布局

不定宽高垂直居中：

* flex
* table-cell
  * 父元素table-cell，并设置vertical-align
* position
  * margin-top:50%
  * transform:translateY(-50%)
  * 如果定宽还可以使用负margin

一侧固定一侧自适应：

* float
  * 一侧浮动设置固定宽度
  * 一侧设置margin
* 创建bfc
  * 一侧浮动设置固定固定宽度
  * 一侧创建bfc
* flex
* grid

两侧固定，中间自适应：

* flex

* position

* grid

* float

  ```css
  /* 注意书写顺序 */
  .left {
      float: left
  }
  
  .right {
      float: right
  }
  ```

元素平分布局：

* table

  * 父元素display:table
  * 子元素display:table-cell

* flex

  * 纵向布局

  * 设置flex:1

* float+width

* grid

等高布局：

* table
  * 父元素设置distplay:table
  * 子元素设置display:table-cell
* flex

### 渐进增强和优雅降级

* 前者针对低版本浏览器开发，保证基本功能；再针对高版本浏览器添加新特性，提高用户体验
* 后者针对高版本浏览器开发，再对低版本浏览器进行兼容

### 盒模型

box-sizing：

* border-box：IE
* content-box：默认

获取元素宽高：

* dom.style.width：行内样式，带单位
* dom.getBoundingClientRect.width
* dom.offsetWidth

### 百分比

* line-height的百分比是以当前元素font-size为参照
* vertical-align的百分比是当前元素的line-height为参照

### 清除浮动

* 父元素给定高度
* 触发bfc
* clear:both

### 定位

* static

* absolute

* relative

* stiicky

  * 到达指定位置之前，表现为relative
  * 导致指定位置之后，表现为absolute

  缺点：

  * 兼容性问题

### 包含块

元素的盒模型属性width，height，margin和padding的百分比是基于containing block来计算的，其中其中margin和padding的百分比是基于包含块的宽度计算的。

* 一般是最近的块级父元素的content area
* 绝对定位的包含块是最近的已经定位的padding box
* 绝对定位的包含块是viewport

### BFC

决定内部元素如何布局定位，以及和其它元素的相互作用。

应用场景：

* 解决边距折叠
* 清除浮动
* 布局

创建BFC：

* float不为none
* position不为static
* overflow不为visible
* 根元素
* display为flex，inline-block等
* 触发ie的hasLayout属性

### 硬件加速

* transition3D(0,0,0)
* translateZ(0)

## JS

### 数据类型

基本数据类型：

* null
* undefined
* number
* string
* boolean
* symbol

引用数据类型：

* function
* array
* object

### 包装类型

为了让js看起来一切皆对象。

### null和undefined

null和undefined的区别：

* null表示定义了，但是值为空
* undefined表示变量未被赋值
* null可以通过null关键字来获取，而undefined不可以，你需要通过void+表达式来获取（设计失败）
* 两者在非严格等于的时候为true

### boolean

假值：

* null
* undefined
* 0
* ""
* false

### number

JS中的Number类型符合IEEE 754-2008规定的双精度浮点规则，但是JS为了表达几个额外的语言场景，例如不让除以0出错，引入了：

* NaN
* Infinity
* -Infinity

为什么会有精度问题，即0.1+0.2不等于0.3？

* 计算机本质是只能识别二进制，所以将0.1转换为二进制是一个无限循环的小数，而js的number类型是使用双精度浮点数表示的，其小数部分最多是52位，也就是0.1在转换为二进制表示的时候会被截断，所以导致结果出错
* 不是只有js有这个问题，像python，java这些使用IEEE 754标准储存浮点类型的编程语言都有这个问题

解决办法：

* 尽量不要操作小数，如果需要操作小数，可以转换为整数后再进行操作，最后再转换为整数
* 使用第三方库，例如number-precision

### symbol

意义：

* 解决js中对象中key命名冲突的问题，例如任意两个symbol不相等，尽管描述相同
* 除了自定义symbol之外，js还内置许多symbol

场景：

* 对象内置[Symbol.iterator]，指向该对象的默认遍历器方法，可以用于`for...of`循环

* 对象内置[Symbol.toPrimitive]，当一个对象转换为原始值时，会调用此函数

  ```js
  var obj2 = {
    [Symbol.toPrimitive](hint) {
      // hint 表示期待转换的数据类型
      if (hint == "number") {
        return 10;
      }
      if (hint == "string") {
        return "hello";
      }
      return true;
    }
  };
  console.log(+obj2);     // 10      -- hint 参数值是 "number"
  console.log(`${obj2}`); // "hello" -- hint 参数值是 "string"
  console.log(obj2 + ""); // "true"  -- hint 参数值是 "default"
  ```

### array

类数组转换为数组：

* [...]
* Array.from
* [].slice.call(arr)

数组去重：

* set
* filter
* 循环 + includes

```js
const arr = [1,2,3,4,5,2,3]

// set
[...new Set(arr)]
Array.from(new Set(arr))

// filter
const newArr = arr.filter((item, index, arr) => arr.indexOf(item, 0) === index);

// 循环+IndexOf
const newArr = [];
arr.forEach(item => {
  if (newArr.indexOf(item, 0) === -1) {
    newArr.push(item);
  }
});

// 循环+includes
const newArr = [];
arr.forEach(item => {
  if (!newArr.includes(item)) {
    newArr.push(item);
  }
});

console.log(newArr);
```

数组对象去重：

* filter+findIndex

  ```js
  const arr = [
    {
      id: 1,
      name: "ugu"
    },
    {
      id: 1,
      name: "ugu"
    },
    {
      id: 2,
      name: "mo"
    }
  ];
  
  const newArr = arr.filter((item, index) => {
    return arr.findIndex(ele => ele.id === item.id) === index;
  });
  ```

* reduce

  ```js
  const newArr = arr.reduce((prev, next) => {
      if(!arr.find(el => el.id === next.id)) {
          prev.push(next)
      }
      return prev
  },[])
  ```

数组方法：

* concat
* every
* filter
* map
* reduce
* find
* findIndex
* indexOf
* lastIndexOf
* forEach
* pop
* push
* shift
* unshift
* splice
* reverse
* sort
* join
* some
* slice
* includes
* keys
* values
* fill

### object

对象描述符：

* value：属性的值
* writable：是否可以被赋值
* enumerable：是否可以被`for...in`枚举
* configurable：该属性能否被删除或者改变描述

对象描述符可以通过`getOwnPropertyDescriptor`来获取。

分类：

* 内置对象
* 宿主对象（运行环境定义的对象）
* 自定义对象

对象拷贝：

* 浅拷贝

  * {...}
  * Object.assign
  * 直接赋值
  * Array.prototype.concat
  * Array.prototype.slice
  * Array.from

* 深拷贝

  * 递归

    ```js
    function checkType(obj) {
      return Object.prototype.toString.call(obj);
    }
    
    function deepClone(obj) {
      let result = null;
      let type = checkType(obj);
    
      if (type === "[Object object]") {
        result = {};
      } else if (type === "[Object array]") {
        result = [];
      } else {
        return obj;
      }
    
      for (const key in obj) {
        const current = obj[key];
        if (
          checkType(current) === "[Object object]" ||
          checkType(current) === "[Object array]"
        ) {
          result[i] = deepClone(current);
        } else {
          result[i] = current;
        }
      }
      return result;
    }
    ```

  * JSON.parse(JSON.strinify())

    缺点：

    * 时间对象会转换为字符串形式
    * function和undefined会丢失
    * 正则和error对象会序列化为空对象

  * lodash

### 函数

定义方式：

* 函数定义
* 函数表达式
* 构造函数
* 箭头函数

缓存函数：

* 实现：

  ```js
  function mem(fn) {
    let cache = Object.create(null);
  
    return function(...key) {
      if (!cache[key]) {
        cache[key] = fn.apply(this, key);
      }
  
      return cache[key];
    };
  }
  
  function add(a, b) {
    return a + b;
  }
  
  const memAdd = mem(add);
  console.log(memAdd(1, 2));
  console.log(memAdd(1, 2));
  ```


柯里化：

* 概念：
  
* 将一个多参函数转换成一个嵌套的一元函数的过程，就称为柯里化
  
* 优点：

  * 减少代码冗余
  * 增加可读性
  * 分布计算，惰性求值

* 缺点：

  * 基于闭包实现，可能会造成内存泄漏
  * 基于递归实现，性能可能过低。递归过多可能会发生栈溢出，需要尾递归优化

* 应用场景：

  * 减少重复传递不变的部分参数

* 实现

  ```js
  const curry = function(fn) {
    let args = [].slice.call(arguments, 1);
    return function() {
      args = args.concat([...arguments]);
      return args.length >= fn.length ? fn(...args) : arguments.callee;
    };
  };
  ```

compose：

* 实现：

  ```js
  function demo1(x) {
    return x + 1;
  }
  
  function demo2(x) {
    return x + 2;
  }
  
  function demo3(x) {
    return x + 3;
  }
  
  const funcs = [demo1, demo2, demo3];
  
  const compose = funcs.reduce((a, b) => x => a(b(x)));
  
  console.log(compose(1));
  ```

* 应用场景：redux中间件组合执行

this：

* 普通函数的this指向调用者，在函数执行阶段确定
* 箭头函数的this基于词法作用域，会进行作用域链查找

箭头函数：

* 没有this，this基于词法作用域，由上下文决定，所以call和apply无法对this进行绑定
* 没有arguments，也是由上下文决定

### 类型转换

==和===

* 前者遇到类型不同时，会做隐式类型转换后再进行值比较，若值不同，则返回false，否则返回true
* 后者遇到类型不同时直接返回false
* 尽量使用严格等于

对象转换为基本数据类型：

* ES5之前会尝试进行调用valueOf和toString方法进行转换
* ES6之后，转换方法会调用[Symbol.toPrimitive]，你可以重写转换规则

### 类型检测

typeof：

* 可以用来检测基本数据类型，缺点是无法检测null和object

```js
typeof null  'object'
typeof {}    'object'

// 注意
typeof function a() {}		// 'function'
```

instanceof：

* 原理：基于原型链，即操作符右边的原型对象是否在操作符左边的原型链上
* 缺点：无法检测null和undefined

```js
function myInstanceof(left, right) {
  let prototype = right.prototype;

  left = left.__proto__;

  while (true) {
    if (left === null || left === undefined) {
      return false;
    }
    if (prototype === left) {
      return true;
    }

    left = left.__proto__;
  }
}
```

Object.prototype.toString.call(data)

```js
Object.prototype.toString.call(1)		// "[Object number]"
```

### 作用域

作用：

* 控制变量的可见性和生命周期，减少命名冲突，提供了自动内存管理

分类：

* 全局
* 函数

作用域链

* 作用域相互嵌套，形成一个链式结构
* 这个链式结构提供了变量的访问规则，具体是如果当前作用于下没有变量，就会一直向上层寻找

### 原型和原型链

原型：

* 不同基于类实现继承的编程语言，js是通过原型实现继承，用语法表示就是prototype
* 实例对象的原型（`__proto__`）指向其构造函数的prototype属性，该实例对象的constructor属性指向构造函数本身
* es6新增class关键字，本质还是使用prototype进行模拟

原型链：

* 原型对象还是有原型对象，原型对象上面还有原型对象，这样一层一层，形成一条原型链
* 原型链规定了对象属性的查找规则，即访问一个对象上的属性会进行原型链查找

设置原型的方法：

* Object.create
* Object.setPrototypeof
* Object.getPrototypeof
* `__proto__`

new的过程：

1. 创建一个空对象
2. 绑定原型
3. 绑定this
4. 执行函数
5. 返回这个空对象

```js
function create(fn, ...args) {
  let obj = {};

  obj.__proto__ = fn.prototype;

  const result = fn.call(obj, ...args);

  return result instanceof Object ? result : obj;
}
```

### 闭包

闭包本质上就是一个绑定了上下文执行环境的函数，是基于词法作用域书写代码的必然结果。可以简单理解为是函数内部和函数外部的一座桥梁。

```js
function foo() {
    const a = 1
    return function() {
        console.log(a)
    }
}
```

优点：

* 可以读取函数内部的变量

缺点：

* 可能会造成内存泄漏

### 上下文

执行上下文，就是一个执行环境。当js代码执行时，会产生一个对应的执行环境：

* 全局上下文：只有一个
* 函数上下文
* eval上下文

特点：

* 单线程，在主线程上执行
* 同步执行，从上到下依次执行
* 会产生预解析，例如变量声明提升

### 单线程

原因

* 防止线程竞争，保持简单性

问题：

* cpu需要长时间等待io返回

解决：

* event loop

缺点：

* 无法利用多核cpu
  * 浏览器：web worker
  * node：child_process和cluster
* 一个错误会导致整个应用崩溃
* 大量计算会导致cpu无法继续调用异步io
  * 浏览器端：web worker
  * node：C++扩展

### event loop

宏任务：

* setTimeout
* setInterval
* setImmediate(Node)
* requestAnimationFrame(浏览器)
* message channel
* postMessage
* Nodejs IO
* UI rendering

微任务：

* Promise.then()
* Process.nextTick(Node)
* MutationObserver

浏览器：

js代码在执行过程中，如果遇到异步代码，就会挂起放到任务队列中，其中微任务放到微任务队列，宏任务放到宏任务队列。执行栈执行完同步代码后，会去检查微任务队列，如果不为空，就按照先入先出的规则一次性执行完微任务队列。注意：如果此时执行微任务的过程中又产生了微任务，那么就会加入到队列的末尾，也会在这个周期执行。当微任务队列执行结束之后，会取出宏任务队列中处于队首的任务，放到执行栈中执行，并在执行结束后，再次检查执行微任务队列，这种不断读取异步任务队列的机制，称为event loop。

Node：基于libuv

* 宏任务队列：
  * timers：处理定时器，setInterval，setTimeout
  * IO callbacks
  * idle，prepare：仅供系统内部调用
  * poll：获取新的IO事件
  * check：处理setImmediate
  * close callbacks：处理socket的close事件
* 微任务队列：
  * tick queue：process.nextTick
  * other micro queue：其它微任务，例如promise

具体流程：

* 执行全局同步代码
* 执行微任务队列，先执行tick队列，再执行其它微任务队列
* 执行宏任务队列的各个阶段，每个阶段执行结束后，会重新检查执行微任务队列

区别：

* nodejs异步队列个数不同，浏览器端就两个，而node端有八个
* 执行时机不同，浏览器环境下，微任务队列会在每个宏任务执行之后执行。在node下，微任务队列在每个宏任务队列的各个阶段之间执行

### worker

* web worker
  * 处理计算密集型任务
  * 并未改变单线程本质，仍然由主线程控制，不能访问dom
* service worker
  * 多用于缓存

### 异步解决方案

* 回调

  缺点：

  * 回调地狱
  * 无法使用try...catch捕获错误

* 发布订阅

* promise

* generator

* async/await

### promise

三种状态：

* pending
* fulfilled
* rejected

状态改变是单向的，一旦改变就不能再变。

静态方法：

* Promise.resolve()
* Promise.reject()
* Promise.race()
  * 将多个promise实例包装成一个新的promise实例
  * 当多个promise实例中先改变状态，新生成的promise实例就是什么状态
* Promise.all()
  * 将多个promise实例包装成一个新的promise实例
  * 当多个promise实例的状态都为fulfilled时，新的promise实例才会是fulfilled，并且多个promise实例的返回值会组成一个结果数组返回
  * 当多个promise实例的状态有一个为rejected时，新的promise实例就是rejected状态，此时第一个rejected实例的返回值会返回

原理：

```js
// Promise
function Promise(fn) {
  this.status = "pending";
  this.value = null;
  this.reason = null;

  const resolve = val => {
    this.value = val;
    this.pending = "fulfilled";
  };

  const reject = err => {
    this.reason = err;
    this.pending = "rejected";
  };

  try {
    fn(resolve, reject);
  } catch (error) {
    reject(error);
  }
}

Promise.prototype.then = function(successCb, errorCb) {
  if (this.status === "fulfilled") {
    successCb(this.value);
  }

  if (this.status === "rejected") {
    errorCb(this.reason);
  }
};

// Promise.all
Promise.myAll = function(promiseArray) {
  const results = [];
  return new Promise((resolve, reject) => {
    promiseArray.forEach((promise, index) => {
      promise.then(res => {
        results.push(res);

        if (promiseArray.length === index + 1) {
          resolve(results);
        }
      });
    });
  });
};

// Promise.race
Promise.myRace = function(promiseArray) {
  return new Promise((resolve, reject) => {
    promiseArray.forEach((promise, index) => {
      promise
        .then(res => {
          resolve(res);
        })
        .catch(err => reject(err));
    });
  });
};
```

then：

* then可以被同一个promise调用多次
* promise内部throw error，相当于reject(error)
* promise的then和catch都可以链式调用，当then链式调用时，下一个then的值是上一个promise变成fulfilled的返回值，这个返回值可以值，也可以是promise。当是值时，会被包装成promise
* 构造函数中resolve或reject只执行依次，多次执行无效
* 穿透，简单来说就是then和catch接收的都是函数，如果是接收的是非函数，那么就会忽略，将promise的返回值传递给下个then或catch

实现sleep：

```js
const sleep = function(delay) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve,delay)
    })
}
```

### generator和iterator

迭代器：

* 为了统一迭代逻辑，之前一直使用forEach，for...in等循环来迭代，现在统一使用for...of
* for...of会自动调用对象的[Symbol.iterator]接口，目前，字符串，数组，map和set等数据结构都内置了这个接口的实现
* 迭代器对象都有一个next方法，调用该函数会返回一个结果对象，包含value和done属性，当done为true时，则表示迭代结束

生成器：

* 可以生成迭代器，主要是为了控制函数的执行流程

* 现在多用来控制异步的执行流程

```js
function* gen() {
  console.log(1);
  yield 1;
  console.log(2);
  yield 2;
  console.log(3);
  yield 3;
}

const it = gen();

console.log(it.next());
console.log(it.next());
console.log(it.next());
```

### async/await

* async函数必定返回Promise
* await后面跟上Promise

原理：

* 本质是co+generator

### set/map

* set
  * 新的数据结构，类似数组，不过成员必须是唯一
* map
  * 新的数据结构，类似对象，但是key不一定非得是字符串
* weakSet
  * 新的数据结构，只允许你将一组弱引用对象存储起来
  * 和set不同，weakSet只允许存储对象，而set对象和值都可以
  * 和set不同，weakSet不允许遍历
* weakMap
  * 新的数据结构，只允许你将弱引用对象作为key值，而value没有类型限制
  * 和map不同，weakMap不允许遍历

应用场景

* weakMap存储的对象和对象关联的数据，会在对象被销毁后，关联的数据会被自动释放，不会内存泄漏

### let和const

var：

* hoisting
* 全局window属性

let和const：

* 不会hoisting
* 不会成为全局window属性
* let定义变量，const定义常量

### call,apply和bind

区别：

* 都可以绑定this，第一个参数就是需要绑定this的函数
* call和apply绑定this的函数会立即执行，而bind会返回一个新函数，需要手动执行
* call和apply接收参数形式也不同，前者是参数列表，后者参数数组

手动实现：

```js
Function.prototype.myCall = function(ctx = window) {
  if(typeof this !== 'function') {
    throw new TypeError('caller is not a function')
  }

  const args = [...arguments].slice(1)
  return this(...args)
}

Function.prototype.myApply = function(ctx) {
  if (typeof this !== "function") {
    throw new TypeError("caller is not a function");
  }

  ctx = ctx || window;
  ctx.fn = this;

  const args = [...arguments].slice(1)
  return ctx.fn(...args);
};

Function.prototype.myBind = function(ctx) {
  ctx = ctx || window;
  const self = this;
  const args = [].slice.call(arguments, 1);

  return function() {
    return self.apply(ctx, [...args, ...arguments]);
  };
};
```

### reduce,filter,map,some和every

```js
// reduce
Array.prototype.myReduce = function(fn, initValue) {
  if (typeof fn !== "function") {
    throw new TypeError("arguments is not a function");
  }

  for (let i = 0, len = this.length; i < len; i++) {
    initValue = fn(initValue, this[i]);
  }

  return initValue;
};

const arr = [1, 2, 3];
const b = arr.myReduce((prev, next) => prev + next, 0);
console.log(b);


// filter
Array.prototype.myFilter = function(fn) {
  if (typeof fn !== "function") {
    throw new TypeError("arguments is not a function");
  }

  const arr = [];

  for (let i = 0, len = this.length; i < len; i++) {
    if (fn(this[i])) {
      arr.push(this[i]);
    }
  }

  return arr;
};

const arr = [1, 2, 3];
const b = arr.myFilter(item => item > 2);
console.log(b);


// map
Array.prototype.myMap = function(fn) {
  if (typeof fn !== "function") {
    throw new TypeError("arguments is not a function");
  }

  const arr = [];

  for (let i = 0, len = this.length; i < len; i++) {
    arr.push(fn(this[i]));
  }
  return arr;
};

const arr = [1, 2, 3];
const b = arr.myMap(item => item + 2);
console.log(b);


// some
Array.prototype.mySome = function(fn) {
  if (typeof fn !== "function") {
    throw new TypeError("arguments is not a function");
  }

  for (let i = 0, len = this.length; i < len; i++) {
    if (fn(this[i])) {
      return true;
    }
  }
  return false;
};

const arr = [1, 2, 3];
const b = arr.mySome(item => item > 2);
console.log(b);
```

### 防抖和节流

防抖：

* 多次触发不执行，一段时间后不触发才执行

```js
const foo = function(fn, delay) {
    let timer = null
    return function() {
        if(timer) {
            clearTimeout(timer)
        }
        
        timer = setTimeout(() => {
            fn.apply(this, arguments)
        },delay)
    }
}
```

节流：

* 持续触发不会执行多次，到一定时间才会执行

```js
const foo = function(fn, delay) {
    let flag = true
    return function() {
        if(!flag) {
			return             
        }
        flag = false
    	
        setTimeout(() => {
            fn.apply(this, [...arguments])
            flag = true
        },delay)
    }
}
```

### GC

垃圾收集器会周期性的回收没有被继续使用的变量，释放内存。

两种方式：

* 标记清除
  * 当变量进行环境会被标记成进入
  * 当变量离开环境会被标记为离开
  * 标记为离开的变量会被视为准备删除的变量，最后会被GC回收
* 引用计数
  * 追踪记录每个值被引用的次数
  * 当一个引用类型赋值给一个变量，引用次数就加一
  * 当引用的次数为零时，则会被GC回收，释放内存

区别：

* 大部分浏览器的js引擎是使用标记清除的方法
* 这是因为引用计数存在循环引用的问题，可能会导致内存泄漏

内存泄漏点：

* 未释放的闭包
* 大量全局变量
* 未清除的定时器
* 未及时清除DOM绑定的事件
* 内存当缓存（node）

内存泄漏和内存溢出：

* 前者是占用的内存未及时释放
* 后者是程序需要内存超出物理内存

堆内存和栈内存：

* 概念：
  * 基本数据类型存储在栈内存中
  * 引用数据类型存储在堆内存中
* 区别：
  * 栈内存：由操作系统自动分配释放
  * 堆内存：一般由程序员手动释放，否则将会由os来回收

### 严格模式

es5引入了严格模式来让javascript在严格条件下执行，具体表现在：

* 不允许使用未声明的变量
* 删除不可配置属性报错，而不是静默失败
* 只读属性赋值报错，而不是静默失败
* 禁止出现动态作用域，例如使用with语句和创建eval作用域
* ...

意义：

* 消除js部分语法的不合理，不严谨之处，减少一些怪异行为

* 消除一些代码的不安全之处，保证代码运行安全

* 提高编译器效率
* 为未来的js做好铺垫

### 正则表达式

贪婪模式：

* 当使用量词来指定重复的次数，默认情况下是最大可能匹配

  ```js
  const str = '123456'
  const newStr = str.replace(/\d{2,4}/, 'x')
  
  console.log(newStr)			
  ```

千位分隔符：

```js
function fn(str) {
  let newStr = "";
  for (let i = 0, len = str.length; i < len; i++) {
    if (i % 3 === 0 && i !== 0) {
      newStr += `,${str[i]}`;
      continue
    } 
      
    newStr += str[i];
  }

  return newStr;
}

// 还可以通过正则来实现
```

### 事件

分类：

* addEventListener：绑定事件
* removeEventListener：解绑事件
* dispatchEvent：触发事件

注册事件：

```js
const btn = document.querySelector('button')
btn.addEventListener('click',{
    handleEvent: handler
},{
    once: true,				// 只触发一次，然后自动移除
    capture: false			// 不在捕获阶段触发，只在冒泡阶段触发
})
```

事件传播：

当一个事件触发时，会在子元素和父元素之间传播（`propagation`），这种传播分为如下三个阶段：

* 第一阶段：从`window`对象向下传递到目标节点，称为捕获阶段（`capture phase`）
* 第二阶段：在目标节点上触发，称为目标阶段（`target phase`）
* 第三阶段：从目标节点向上传递给`window`对象，称为冒泡阶段（`bubbling phase`）

例如你点击一个按钮，事件的传播顺序如下：

* 捕获阶段：window->document->document.documentElement->document.body->button
* 冒泡阶段：button->document.body->document.documentElement->document->window

事件代理：

* 由于事件传播机制，可以将子元素的监听函数定义在父节点上，交由父节点统一处理，这个机制称为事件代理
* 优点：
  * 节省内存
  * 子组件动态绑定事件

currentTarget和target的区别：

* 前者指向绑定事件的dom节点
* 后者指向触发事件的dom节点

stopstopPropagation和stopImmediatePropagation：

* 前者用于阻止事件继续传播，但是不会阻止同一个事件的多个回调函数的执行
* 后者也可用于阻止事件继续传播，还会阻止同一个事件的多个回调函数的执行，如果其中一个监听函数调用了该方法，后续的监听函数就不会在执行

mouseenter和mouseover：

* mouseenter不会冒泡，也就是说如果没有子元素，二者行为是一致的。如果有子元素，则两者行为不一致。

### dom操作

节点信息：

* nodeType
* nodeName
* nodeValue

获取dom：

* getElementById
* getElementsByTagName
* getElementsByClassName
* querySelector
* querySelectorAll
* node.parentNode
* node.children || node.childNodes
* previousSibling 
* nextSibling

修改节点的文本：

* innerHTML
* outerHTML
* textContent

修改节点的样式：

* node.style.cssProperty

操作节点的属性：

* setAttribute
* getAttribute

创建节点：

* createElement
* createTextNode
* createDocumentFragment

添加节点：

* appendChild
* innerHTML
* insertBefore

克隆节点：

* cloneNode

删除节点：

* removeChild

### 拖拽api

* ondragstart:源对象开始被拖动
* ondrag:源对象被拖动的过程中
* ondragend:源对象被拖动结束
* ondragenter:目标对象被源对象拖动进入
* ondragover:目标对象被源对象悬浮在上面
* ondragleave:源对象拖动着离开了目标对象
* ondrop:源对象拖动着在目标对象上方松手

### requestAnimationFrame

背景：

* 很多js动画都是基于定时器来实现的，这种方式有两个缺点：
  * 动画时间间隔不好确定，太长不够平滑，太短容易卡顿，推荐设置17ms(因为屏幕的刷新频率一般是60hz)
  * 时间参数不准确，第二个时间参数只是push到队列中的时间，并不是实际执行的时间，如果当前线程处于忙碌状态，是无法准确响应时间参数的

解决：

* requestAnimationFrame可以有效解决dom动画的性能问题，希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画 

## 浏览器

### 内核

* ie：trident

* safari：webkit
* firefox：gecko
* chrome和opera：blink
* 国内的一些浏览器：兼容模式使用ie，急速模式使用blink

### url请求过程

1. 从url中解析出域名
2. 通过dns查询出ip地址（浏览器缓存->本地系统hosts缓存->dns服务器）
3. 三次握手建立tcp链接
4. 发送http请求
5. 服务器响应请求
6. 浏览器接收请求
   * dom tree（并行）
   * cssom（并行）
   * render tree
   * layout
   * render
   * draw
7. 四次挥手释放tcp链接

### 回流重绘

概念：

* 回流：当修改元素的尺寸，布局等属性时，浏览器重新构建dom的过程，称为回流

* 重绘：如果修改的属性不影响元素在normal flow的位置，例如color，background-color，仅仅重新绘制称为重绘

区别和联系：

* 两者都消耗性能
* 回流必然会导致重绘

回流的触发条件：

* DOM tree变化，例如添加或删除dom元素
* render tree变化，例如修改元素的width属性
* 窗口resize
* 页面第一次渲染
* 获取某些盒模型属性，例如offsetLeft，offsetTop，offsetWidth，offsetHeight等

重绘触发的条件：

* 回流必然导致重绘
* 颜色或者背景色发生改变

优化手段：

* 缓存DOM
* 避免逐个修改节点样式，尽量一次性修改
* 使用documentFragment做批量更新
* 多次操作DOM可以将该元素设置display:none，操作完再显示出来
* 可以将操作的dom脱离文档流后再操作，降低回流成本

### 加载阻塞

加载js会阻塞DOM构建：

* 将js放在body尾部
* 使用异步脚本

异步脚本：

* 通过async和defer声明异步脚本，不会阻塞DOM构建
* 前者会在脚本下载好后立即执行，适合不依赖顺序执行的脚本
* 后者下载好之后不会立即执行，会在DOM解析之后，DOMContentLoaded之前执行，适合依赖顺序执行的脚本

### 标签页之间通信

* websocket
* postMessage
* local storage

### 客户端存储

* cookie
* localstorage
* sessionstorage
* indexDB

区别：

* cookie可以手动设置失效期，默认为会话级；sessionStorage是会话级，localStorage是永久级，除非用户手动删除
* localStorage和sessionStorage的访问限制是文档级别，即协议，主机名和端口；而cookie是可以在通过设置domain属性值，在不同二级域名下共享
* cookie在存储个数上有限制，适合存储少量数据，而storage是可以存储稍微大量数据
* cookie通过document.cookie进行操作；storage通过getItem和setItem来进行操作
* cookie会和服务器端进行交互，而storage不会
* cookie还可以通过服务器端进行限制，例如http-only

### cookie

除了基础的键值对外，cookie还有下面的属性：

- Expires ：cookie最长有效期
- Max-Age：在 cookie 失效之前需要经过的秒数，若和Expires同时存在，以Max-Age为准
- Domain：指定 cookie 可以送达的主机名。
- Path：指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部
- Secure：一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器。
- HttpOnly:设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由 `Document.cookie` 属性、`XMLHttpRequest` 和 `Request` APIs 进行访问，以防范跨站脚本攻击

### 断点续传

range请求

### 断网状态监听

```js
window.addEventListener('online', () => {})

window.addEventListener('offline', () => {})
```

### 查看内存

* 浏览器端通过performance接口
* node端通过process模块的memoryUsage

## http

http：

* 基于tcp，因为tcp安全可靠
* 无状态的

组成：

* 请求
  * 请求头：协议和版本，以及请求头
    * User-Agent
    * Cookie
    * Cache-Control
    * If-Modified-Since
    * If-None-Match
    * ...
  * 请求方法：请求动词
    * head：没有请求体，只有请求头，轻量
    * get：多用于查询
    * post：多用于创建
    * delete：删除
    * put：局部更新
    * update：整体更新
    * options：预检请求
  * 请求体：包含数据
* 响应
  * 响应头
    * ETag
    * Keep-Alive
    * Content-Type
    * Last-Modified
    * ...
  * 响应体：响应的数据
  * 状态码：表示响应的状态
    * 200：成功
    * 201：创建资源成功
    * 204：请求成功，没有结果返回，例如options请求
    * 301：永久重定向
    * 302：临时重定向
    * 304：可以使用缓存，不会有请求体
    * 401：无权限
    * 403：拒绝请求
    * 404：not found
    * 500：服务器错误
  

get和post的区别：

* 前者用于查询资源，后者用于操作资源
* 前者具有幂等性，后者则不是
* 前者请求反映在url上，并且有长度限制，后者则没有，所有后者更安全一些

https：

* 是http的安全版本，http明文传输，https加密传输
* https是443端口，http是80
* 因为加了一层ssl，所以握手效率不如延长，并且ca证书需要钱


http2：

* 支持服务器推送
* 支持TCP链接复用，避免了tcp链接和释放的握手开销
* 首部压缩，http2引入了HPACK算法对头部进行压缩，减少了数据发送的字节数

websocket：

* 概念：
  * 和http一样，属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端 
* 区别：
  * ws基于udp，http基于tcp
  * http只能由客户端发起，ws是双向的
  * ws没有同源策略限制

### 缓存

意义：

* 减轻服务器压力
* 减少http请求
* 提升用户体验

强缓存：不与服务器做交互

* expires
  * http1.0
  * 使用绝对时间
  
* Cache-control
  
  * 协议：
    * http1.1
  
  * 区别：
    * 以秒为单位，用数字表示
    * 如果同时存在，以cache-control为准
  
  * 值：
    * public：都能缓存
    * private：只有客户端能缓存，CDN不能缓存
    * no-store：禁止缓存
    * no-cache：禁止本地缓存，走协商缓存 
  

协商缓存：浏览器发送请求，服务器判断是否可以用本地缓存

* 概念：通过下面两个header来管理

* last-modified

  * if-modified-since

  * 精确到1s
* etag

  * if-none-match

具体流程：

1. 浏览器发送请求，判断是否有缓存
2. 有缓存，并且缓存没有过期，那么直接使用强缓存
3. 若缓存过期，判断是否有etag和last-modified，如果没有，需要返回新数据
4. 如果有，根据请求携带的if-none-match和if-modified-since判断缓存是否可用
5. 如果缓存不可用，重新返回
6. 如果缓存可用，告知浏览器可以使用缓存

最佳实践，尽可能的命中强缓存，具体：

* html文件使用协商缓存
* css，js和图片使用强缓存，并打上hash

### 跨域

原因：

* 同源策略，即协议，端口以及域名不同

限制：

* ajax请求限制（可以发送，但是浏览器拒绝接收响应）
* cookie，storage和indexDB

解决方法：

* jsonp

  原理：

  * 利用script的src不受跨域限制
  * 具体做法，服务端返回`"show('数据')"`，客户端全局定义一个`show`方法接收数据

  ```js
   const jsonp = (url, cb) => {
       return new Promise((resolve, reject) => {
           const script = document.createElement("script");
  
           window[cb] = function(data) {
               resolve(data);
               document.body.removeChild(script);
           };
  
           script.onerror = function(err) {
               reject(err);
           };
  
           script.src = url;
  
           document.body.appendChild(script);
       });
   };
  
  jsonp("http://localhost:3000/?cb=show", "show").then(res =>
                                                       console.log(res)
                                                      );
  ```

* cors

* websocket

* postmessage

* 反向代理

* 基于iframe的跨域方案

### 预检请求

cors，简称跨域请求会将请求分为两种：

* 简单请求
  * 动词必须是GET，HEAD或POST
  * 头必须是Content-Type等 
* 非简单请求
  * 动词是PUT，DELETE等

对于非简单请求，需要先发送一个预检请求来知道服务器是否支持跨域或者是否支持当前请求动词。

### 网络模型

* 物理层
* 数据链路层
* 网络层
* 传输层
* 会话层
* 表示层
* 应用层

其中tcp属于传输层，http属于应用层。

### TCP和UDP

* TCP是一种可靠的数据传输方式，数据传输之前必须建立客户端和服务器之间的链接，所以通过TCP协议传输的数据都是可靠的，不丢失，无差错的
* UDP是面向非连接的协议，所以通过UDP协议传输的数据是尽可能交付，不是可靠交付，所以传输速度快，常应用于实时性要求强的领域，例如实时对战游戏，直播，实时会议等

### TCP握手

* 第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
* 第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量
* 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据

为什么是三次握手：

* 既要保证数据可靠传输，又要保证传输效率

为什么是四次挥手：

* 客户端和服务器都要释放链接
* a->b，a发出断开链接请求，b确定a已经断开
* b也要发出断开链接请求，a确定b断开

### cdn

原理：将用户的访问指向最近的缓存服务器，由缓存服务器直接响应静态资源

### ajax

状态：

* 0：还未发送请求
* 1：已经发送请求
* 2：已经拿到响应数据
* 3：正在解析数据
* 4：可以操作数据

## 第三方库

### jQuery

插件：

```js
$.fn.hg = function() {
    this.css({
        color: 'red'
    })
    return this
}
```

### axios

区别：

* ajax：

  * 需要手动封装，对新手不太友好
  * 兼容性好，功能丰富

  ```js
  const xhr = new XMLHttpRequest();
  
  xhr.open("GET", "/detail/1");
  
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // ...
    }
  };
  
  // xhr.onload = function() {
  //   // ...
  // }
  
  xhr.onerror = function() {
    // ...
  };
  
  xhr.send(null);
  
  ```

* axios

  * promise api
  * 前后端通用
  * 客户端支持防止CSRF
  * 额外的功能，例如提供一些并发请求的接口

* fetch

  * 写法简洁方便
  * 存在兼容性
  * 功能不够丰富，需要手动封装

原理：通过promise封装原生ajax

```js
const axios = {
  get(method, url) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      xhr.open(method, url);

      xhr.onload = function() {
        resolve(xhr.responseText);
      };

      xhr.onerror = function(e) {
        reject(e);
      };

      xhr.send(null);
    });
  }
};
```

拦截器：

```js
axios.interceptors.request.use(
  config => {
    $("#loading").show();
    return config;
  },
  err => {
    return Promise.reject(err);
  }
);

axios.interceptors.response.use(
  res => {
    $("$loading").hide();
    return res.data;
  },
  err => {
    return Promise.reject(err);
  }
);
```

丰富的功能：

* 并发请求
* 取消请求

## 移动web

### 视口

* 布局视口
  * 为了解决pc端网页在mobile端显示问题，一般为980px，和浏览器有关
  * 因此pc网页可以在mobile中显示，只不过元素看起来很小
* 视觉视口
  * 用户看到的可视区域
* 理想视口
  * apple提出
  * 通过meta标签设置
  * 布局视口等于视觉视口

### 布局

* 流式布局
  * 百分比布局
* 弹性布局
  * flex布局
* rem布局
* vw布局

rem布局原理：

* 原理：
  
  * 动态设置html元素的font-size大小
  
* 解决方法：

  * 媒体查询，例如苏宁

  * js计算，例如淘宝的flexible.js

    ```js
    (function(window,document) {
        function setUnit() {
            const htmlDOM = document.documentElement.
            const rem = htmlDOM.clientWidth / 10
            htmlDOM.style.fontSize = rem + 'px'
        }
        setUnit()
        
        window.addEventListener("resize", setHtmlFont);
        /*
        	1. 注意防抖
        	2. body阅读字体没有设置
        */
    })(window,document)
    ```

* 缺点：

  * 页面抖动

### 兼容方案

* 点击高亮
* 禁止移动端手机号码识别
* 移除原生控件样式
* 禁止长按页面弹出菜单

1px问题：

* 原因：
  * retina屏幕下，1个css像素等于2个物理像素
* 解决方法：
  * viewport
  * scale

点击300ms延迟：

* 原因：
  * 防止click和缩放冲突
* 解决方法
  * meta标签禁止缩放，不建议
  * fastClick

点击穿透问题：

* 现象：
  * 点击蒙层，蒙层消失后会触发下面的元素的click事件

* 原因：
  * 触发顺序，touchstart->touchmove->touchend，300ms之后才会有click
  * 也就是说，即使给元素绑定的是touch事件，click事件还是会触发click事件
* 解决方法：
  * 不要混用touch事件和click事件

下拉刷新和上拉加载：

* 下拉刷新：

  原理：

  * 记录e.touches[0]的起始位置
  * 监听touchmove事件
  * 计算滑动的距离，并且通过translate使元素随着手势滑动对应的数值
  * 滑动超过最大值，触发回调函数，并恢复位置

* 上拉加载：

  原理：

  * 当滚动距离加上可视区域大于滚动区域时，触发回调
  * 注意scroll事件要防抖

## vue

### 原生

* 框架大多是组件化开发，易于维护迭代
* 框架性能优异
* 框架生态好
* 框架易于测试
* 框架开发效率高
* 更好的就业机会
* 市场上有成功的案例

### 概念

构建用户界面的渐进式框架，只关注view层。

### mvvm

优点：

* 相较于传统的mvc，解决了操作DOM带来的性能问题，即数据驱动视图
* 并且只关注数据，所以代码整体上提高了维护性

mvc，mvp和mvvm：

* 都是一种代码组织方式

### watch和computed

用法：

* computed可以写成对象形式，有get和set属性
* watch也可以写成对象形式，有handler函数和deep属性

区别和联系：

* 两者都是基于缓存
* computed必须有返回值，watch不需要
* watch支持复杂计算或者异步操作

注意：

* watch深度监听对象时，无法拿到旧的对象，因为对象是引用类型

### class和style

用法：

* 对象形式

  ```js
  :class="{yellow:isYellow}"
  ```

* 数组形式

  ```js
  :class="['yellow', 'black']"
  ```

* 行内形式

  ```js
  :style="{fontSize: '20px'}"
  ```

### v-show和v-if

区别和联系：

* 都可以做条件渲染
* v-if是直接重新创建和销毁组件来控制显示隐藏，而v-show是通过css来控制
* v-if不适合频繁切换的场景，v-show适合

### v-for

key的作用：

* 高效的进行dom diff

注意：

* v-for不建议和v-if一起使用

### v-model

原理：

* input和`:value`

修饰符：

* lazy
* trim
* number

自定义v-model：

```vue
<template>
  <div class="home">
    <Detail v-model="msg" />
    {{msg}}
  </div>
</template>

<script>
import Detail from "./Detail";

export default {
  name: "Home",
  components: {
    Detail
  },
  data() {
    return {
      msg: "demo"
    };
  }
};
</script>

<template>
  <input type="text" :value="val" @input="$emit('change', $event.target.value)" />
</template>

<script>
export default {
  name: "Detail",
  model: {
    prop: "val",
    event: "change"
  },
  props: ["val"]
};
</script>
```

### 事件绑定

事件对象：

* 无参数，直接获取
* 有参数，通过$event传递

注意：

* 事件对象是dom原生事件对象
* target属性是触发的dom元素，currentTarget是绑定事件的dom元素

修饰符：

* stop
* prevent
* capture
* self
* ...

### 组件

组件化：

* 组件：针对UI
* 模块：针对逻辑

分类：

* 全局
* 局部

唯一标识：

* _uid

组件name：

* 递归
* keep-alive
* vue devtools

通信：

* props和$emit
  * props如果不是用来通信，会合并到子组件的根元素上
  * 可以通过设置inheritAttrs关闭这个特性，但是不会影响style和class的绑定
  * 组件上可以使用`.native`监听原生dom事件，如果组件的根元素没有绑定该dom事件，那么只会当作普通属性应用在根元素上
* v-model
* .sync
* provide和inject
* event bus
* vuex

```vue
// props 和 $emit
<template>
	<Child name="ugu" @getMsg="handleMsg" />
</template>

<script>
	props: ['name'], 		// 可以写成对象形式
	mounted() {
        this.$emit('getMsg', 'child data')
    }
</script>

// v-model
<template>
	<Child v-model="msg" />
	{{msg}}
</template>
<script>
	export default {
        data() {
            return {
                msg: ''
            }
        }
    }
</script>

<template>
	<button @click="handleClick"></button>
</template>
<script>
	export default {
        methods: {
            handleClick() {
                this.$emit('input', '子组件数据')
            }
        }
    }
</script>

// .sync
<template>
  <div class="home">
    <Detail :val.sync="msg" />
    {{msg}}
  </div>
</template>

<script>
import Detail from "./Detail";

export default {
  name: "Home",
  components: {
    Detail
  },
  data() {
    return {
      msg: "demo"
    };
  }
};
</script>

<template>
  <button @click="handleClick">emit</button>
</template>

<script>
export default {
  name: "Detail",
  methods: {
    handleClick() {
      this.$emit("update:val", "child data");
    }
  }
};
</script>

//provide inject
<template>
  <div class="home">
    <Detail />
  </div>
</template>

<script>
import Detail from "./Detail";

export default {
  name: "Home",
  components: {
    Detail
  },
  provide() {
    return {
      msg: "demo"
    };
  }
};
</script>

<template>
  <div class="detail">{{msg}}</div>
</template>

<script>
export default {
  name: "Detail",
  inject: ["msg"]
};
</script>
```

注意：

* `$listeners`和`$attrs`也可以通信
* `$parent`和`$children`也可以通信
* $props可以传递所有属性

子组件调用父组件方法：

* $parent
* 子组件触发自定义事件，父组件监听该事件
* 父组件将事件通过props传递
* $listeners

动态组件：

* 通过`:is`绑定动态组件，适合动态渲染的场景

异步组件：

* 通过`import`语法

  ```vue
  <template>
    <div class="home">
      <Detail />
    </div>
  </template>
  
  <script>
  export default {
    name: "Home",
    components: {
      Detail: () => import(/* webpackChunkName: "detail" */ "./Detail")
    }
  };
  </script>
  
  ```

* 应用场景
  * 路由懒加载
  * 首屏优化
    * 异步组件
    * cdn引入
    * 第三方模块按需引入
    * 使用合适的source map
    * 开启gzip压缩
    * 适当的loading效果
    * 分析打包结果

### 生命周期

单个组件：

* 初始化阶段
* 挂载阶段
  * 可以发送ajax请求，但是服务器渲染没有这个生命周期
* 更新阶段
* 销毁阶段
  * 解绑自定义事件
  * 清除定时器
  * 解绑全局绑定的事件

父子组件生命周期：

* 初始化和挂载阶段：
  * 父组件初始化
  * 子组件初始化
  * 子组件挂载
  * 父组件挂载
* 更新阶段
  * 父组件更新前
  * 子组件更新前
  * 子组件更新完成
  * 父组件更新完成
* 销毁阶段
  * 父组件销毁之前
  * 子组件销毁之前
  * 子组件销毁结束
  * 父组件销毁结束

注意：

* 需要自己手动绘制

### 插槽

概念：

* 父组件向子组件分发内容，以达到复用组件的目的

分类：

* 普通插槽

  ```vue
  <div id="app">
  	<component-a>{{msg}}</component-a>		<!--msg绑定的是父组件数据-->
  </div>
  
  let a = {
      template:`<p>
  				<slot>如果父组件没有内容，就默认显示我</slot>	
  			</p>`,								// slot里面绑定的是子组件数据
  }
  new Vue({
      el:"#app",
      data:{
          msg: "hi,ugu"
      },
      components:{
          "component-a":a
      }
  })
  ```

* 具名插槽

  ```vue
  <div id="app">
      <component-a>
          <!-- v-slot可以简写为# -->
          <div v-slot:header>header</div>
          <p>hi,ugu</p>
          <p>hi,ugu</p>
          <div v-slot:footer>footer</div>
      </component-a>
  </div>
  
  let a = {
      template: `<div>=
  				<slot name="header">
  					<div>默认内容1</div>
                    </slot>
  				<slot>
  					<p>默认内容2</p>
  				</slot>
                    <slot name="footer">
  					<div>默认内容3</div>
  				</slot>
  			</div>`,
  }
  
  new Vue({
       el: "#app",
       components: {
           "component-a": a
       }
  })
  ```

* 作用域插槽

  * 父组件使用插槽时，可能需要用到子组件里面的数据，而作用域插槽就是将子组件中的数据传递给父组件中使用

### $nextTick

原理：

* vue观察到数据变化，不会立即操作dom，而是采取异步渲染，而nextTick可以真实渲染dom之后获取真实dom

### keep-alive

概念：

* 保存组件的渲染状态

应用场景：

* 频繁切换，但是不需要重复渲染的组件

钩子函数：

* actived
* deactived

### mixin

目的：

* 复用逻辑

场景：

* 当组件之间有相同的业务逻辑时，可以使用mixin

缺点：

* 可读性较差，复用逻辑处于黑箱之间
* 多个mixin之间可能存在冲突
* 强耦合，不利于项目维护

### render

概念：

* template最终会编译成render函数
* render函数可以使用jsx来写

### 自定义指令

分类：

* 全局
* 局部

原理：

* 不同钩子做不同的事情，如果bind和update触发相同的行为，可以写成函数形式

手写：

```js
Vue.directive('white', (el,binding) => {
	el.style.color = binding.value
})
```

### 原理

vue响应式：

* 概念：
  * 数据修改，视图自动更新
* 原理：
  * 数据劫持
    * Object.defineProperty
    * proxy
  * 发布订阅
    * 依赖收集
    * 通过观察者模式获取数据变化的依赖

数据劫持：

* 监听对象和监听数组

* 复杂对象深度监听

* 源码实现：

  ```js
  const obj = {
    name: "ugu",
    info: {
      msg: "hi"
    },
    arr: [1,2,3]
  };
  
  const oldArrayPrototype = Array.prototype;
  const arrPrototype = Object.create(oldArrayPrototype);
  ["push", "pop", "shift", "unshift", "splice"].forEach(method => {
    arrPrototype[method] = function() {
      updateView();
      oldArrayPrototype[method].call(this, ...arguments);
    };
  });
  
  function observe(target) {
    // 保证必须是数据或对象
    if (typeof target !== "object" || target === null) {
      return target;
    }
      
    if(Array.isArray()) {
        target.__proto__ = oldArrayPrototype
    }
  
    for (const key in target) {
      defineReactive(target, key, target[key]);
    }
  }
  
  function defineReactive(target, key, value) {
    // 原值可能是对象，需要深度监听
    observe(value);
  
    Object.defineProperty(target, key, {
      get() {
        return value;
      },
      set(newVal) {
        if (value !== newVal) {
          // 新值可能是对象，需要深度监听
          observe(value);
  
          value = newVal;
          updateView();
        }
      }
    });
  }
  
  function updateView() {
    console.log("数据改变，需要视图更新");
  }
  
  observe(obj);
  
  obj.name = "guyou";
  obj.info.msg = "demo"; // 深度监听
  obj.info = { message: "demo" }; // 深度监听
  
  obj.x = 1			// 无法监听
  delete obj.name		// 无法监听
  ```

* 缺点：

  * 深度监听，需要递归，计算量太大

  * 无法监听新增属性，所以需要手动Vue.set
  * 无法监听删除属性，所以需要手动Vue.delete
  * 直接修改数组的length无法监听
  * 直接通过索引修改数组无法监听

模板编译：

* vue-template-compiler将模板编译成render函数，执行render函数生成vnode

组件渲染和更新：

* 初次渲染
  * 编译template为render函数，开发环境vue-loader已经完成，没有运行时消耗
  * 触发响应式，即数据劫持
  * 执行render函数，生成vnode
* 更新过程
  * 修改data
  * 重新执行render函数，生成新的vnode
  * dom diff出差异包patch对象
  * 将差异更新到真实dom上
* 注意：需要自己手动绘制出来

异步渲染：

* vue观测到数据变化，不会立即更新dom，而是开启一个队列，并且缓冲在同一事件循环中发生的所有数据改变。如果同一个`watcher`被多次触发，只会被推入的队列中一次。这种机制能够很大程度上避免了不必要的计算和DOM操作。

* 原理：

  * 能力检测，Promise.then和MessageChannel，如果都不支持则使用setTimeout(fn,0)

* 代码实现：

  ```js
  let callbacks = [];
  let pending = false;
  
  function nextTick (cb) {
      callbacks.push(cb);
  
      if (!pending) {
          pending = true;
          setTimeout(flushCallbacks, 0);
      }
  }
  
  function flushCallbacks () {
      pending = false;
      const copies = callbacks.slice(0);
      callbacks.length = 0;
      for (let i = 0; i < copies.length; i++) {
          copies[i]();
      }
  }
  ```

### vue-router

原理：

* 不同的url映射不同的组件

路由模式：

* hash

  * hash变化会触发网页跳转，即浏览器的前进后退
  * hash变化不会刷新浏览器
  * 不和server交互

  代码实现：

  ```js
  window.onhashchange = e => {
      console.log('old url', e.oldURL)
      console.log('new url', e.newURL)
  }
  ```

* history

  * pushState api允许你不刷新界面的情况下修改url
  * 通常结合popstate事件使用
  * 和server交互，否则会报404

  代码实现：

  ```js
  // 监听浏览器前进后退
  window.onpopstate = e => {
      console.log(location.pathname)		// 获取操作后的路径，匹配对应的组件渲染
  }
  
  // 修改url，但是不刷新页面
  btn.onClick = function() {
     let stateObj = {
      foo: "bar",
  } 
  	history.pushState(stateObj, "page 2", "bar.html")
  }
  
  ```

路由模式区别和联系：

* history模式需要后端支持，否则会出现404
* hash模式需要自己在路由中添加404页面
* B端产品建议用hash，C端产品建议用history

动态路由：

* addRoutes

路由懒加载：

* 代码实现

  ```js
  const router = new VueRouter({
      routes: [
          {
              path: '/home', component: () => import('./Home')
          }
      ]
  })
  ```

路由传参：

* query
* param
  * 监听$route
  * beforeRouteUpdate
* 两种方式都可以通过props解耦

路由跳转：

* 编程式
  * this.$router.push
* 声明式
  * router-link

嵌套路由：

* children

路由元信息：

* this.$route.matched

路由守卫：

* 分类

  * 全局
    * beforeEach
    * afterEach
  * 路由
    * beforeEnter
  * 组件级、
    * beforeRouteEnter
    * beforeRouteUpdate
    * beforeRouteLeave

* 执行顺序

  * beforeRouteLeave

  * beforeEach
  * beforeEnter
  * beforeRouteEnter
  * afterEach

route和router的区别：

* 前者是单个路由的信息，包含query和param的信息
* 后者是路由实例，包含一些路由跳转方法

### vuex

原则：

* 单一

基本概念：

* state
* getters
* mutation
* action

action：

* 组件dispatch
* 可以整合mutation
* 可以异步操作，例如ajax请求

mutaion：

* 组件commit
* 具有原子性，即一个mutation只做一件事

简易api：

* mapState
* mapGetters
* mapActions
* mapMutations

注意：

* 需要自己绘制出来

### vue3

proxy重写数据劫持：

```js
function observe(target) {
  if (typeof target !== "object" || target == null) {
    return target;
  }

  return new Proxy(target, {
    get(target, key, value, receiver) {
      return Reflect.get(target, key, receiver);
    },
    set(target, key, val, receiver) {
      if (val === target[key]) {
        return true;
      }
      updateView();
      return Reflect.set(target, key, val, receiver);
    },
    deleteProperty(target, key) {
      return Reflect.deleteProperty(target, key);
    }
  });
}

function updateView() {
  console.log("update view");
}

const obj = {
    name: 'ugu'
}

const proxyData = observe(obj)
obj.name = 'guyou'			// 可以监听
/*
	未实现：
		深度监听
		删除和新增一个属性
		数组处理
*/
```

优点：

* ts支持更好

### 缺点

* api过度封装，缺乏灵活性
* ts支持度不够
* diff算法存在运行时性能消耗

## react

### jsx

* 概念：

  * 描述ui的一种语法

* 基本使用

  * 变量和表达式
  * style和class
  * 原生html
  * 组件

  ```jsx
  const htmlData = {
      __html: '<span>原生html元素</span>'
  }
  
  <div>
      {/*变量和表达式*/}
      <p>{this.state.name}</p>
      {/*style和class*/}
      <p className="black" style={{fontSize: '12px'}}></p>
      {/*原生html*/}
      <div dangerouslySetInnerHTML={htmlData}></div>
      {/*组件*/}
  	<List />
  </div>
  ```

* 条件渲染

  * if else

    ```jsx
    render() {
        if(this.state.flag) {
            return <div>true</div>
        }
        return <div>false</div>
    }
    ```

  * 三元表达式

    ```jsx
    render() {
        return this.state.flag ? <div>true</div> : <div>false</div>
    }
    ```

  * 逻辑运算符

    ```jsx
    render() {
        this.state.flag && return <div>true</div>
    }
    ```

* 循环渲染

  ```jsx
  render() {
      return (
          <div>
          	{
                  this.state.list.map(item => <span key={item.id}>{item}</span>)
              }
          </div>
      )
  }
  ```

* 绑定this

  * 分类

    * 构造函数中
    * 回调中绑定
      * 不建议，每次都会重新生成新的bind函数
    * 静态方法

    ```jsx
    import React from "react";
    
    class App extends React.Component {
      constructor(props) {
        super(props);
        this.state = {};
          
        this.handleClick3 = this.handleClick3.bind(this)
      }
    
      handleClick1 = () => {
        console.log("handle click1");
      };
      
      handleClick2() {
        console.log("handle click2");
      };
    
      render() {
        return (
          <div>
            <button onClick={this.handleClick1}>click1</button>
            <button onClick={this.handleClick3}>click3</button>
            <button onClick={this.handleClick2.bind(this)}>click2</button>
          </div>
        );
      }
    }
    
    export default App;
    ```

  * 传参

    ```jsx
    import React from "react";
    
    class App extends React.Component {
      handleClick(arg, event) {
        console.log(arg);
      };
    
      render() {
        return (
          <div>
            <!--
       		不推荐
    		<button onClick={() => this.handleClick('参数')}>click</button>
    		-->
            <button onClick={this.handleClick.bind(this, '参数')}>click</button>
          </div>
        );
      }
    }
    
    export default App;
    ```

  * 事件对象：

    * 基本概念：

      * React事件并没有在真实的DOM节点上绑定事件，而是通过事件代理，在最外层的document上对事件进行统一分发
    
  * 合成对象，通过e.nativeEvent获取原生事件对象
    
      ```jsx
      import React from "react";
      
      class App extends React.Component {
        handleClick = e => {
          console.log(e);
          console.log(e.native.currentTarget)		// #document
          console.log(e.native.target)			// #button
        };
      
        render() {
          return (
            <div>
              <button onClick={this.handleClick}>click</button>
            </div>
          );
        }
      }
      
      export default App;
      ```
  
* 和原生事件比较：
  
  * 区别：
    * React事件必须使用驼峰命名，而不是全部小写
    * 在React中不能通过return false来阻止默认行为，而是必须明确调用preventDefault
  
    * 目的：
    
      * 更好的兼容性和跨平台
      * 挂载到document，减少内存消耗，避免频繁解绑
      * 方便的事件的统一管理（事务机制）
      
    * 注意：
    
      * 不要混合使用react合成事件和原生dom事件

### 表单元素

分类：

* 受控组件

  * 由react控制的表单元素称为受控组件，例如input元素的value值和state关联起来，这样就能通过控制state来控制input的值

* 非受控组件

  * 表单元素不受react控制，例如state中的数据只是作为input元素的默认值，实际值你需要通过dom去获取

    ```jsx
    import React, { createRef, Component } from "react";
    
    class App extends Component {
      constructor(props) {
        super(props);
        this.state = {
          value: "默认数据"
        };
    
        this.inputDOM = createRef();
      }
    
      handleClick = () => {
        console.log(this.inputDOM.current.value);
      };
    
      render() {
        return (
          <div>
            <input defaultValue={this.state.value} ref={this.inputDOM} />
            <button onClick={this.handleClick}>click btn</button>
          </div>
        );
      }
    }
    
    export default App;
    ```

最佳实践：

* 优先使用受控组件
* 需要手动操作dom的场景可以使用非受控组件，例如文件上传

### 组件

大小写：

* 用来区分组件还是原生HTML元素

分类：

* 类组件：有state和完整的生命周期

  * 状态组件

  * 容器组件

* 函数组件：无state和生命周期

  * 无状态组件

  * ui组件

props：

* 概念：表示组件的属性，由父组件流向子组件，不能子流父，有利于单向数据流
* 验证：
  * prop-type进行prop验证

state：

* 概念：state是当前组件自身状态的描述，通过this.state定义，通过this.setState修改
* 注意：当组件状态发生改变，则render函数重新执行，即当前组件和其子组件重新渲染
* 设计state
  * 首先state的变化应该反应ui的变化
    * 从父组件props中获取的数据不应作为state
    * 数据在整个生命周期中都保持不变不应作为一个state
  * 操作state时，可以使用immer或者immutable来保证state不可变

父子通信：

* props

  ```jsx
  // 父
  import React from "react";
  import Home from "./Home";
  
  class App extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        msg: "父组件数据"
      };
    }
  
    getData(data) {
      console.log(data);
    }
  
    render() {
      return (
        <div>
          <Home msg={this.state.msg} getData={this.getData} />
        </div>
      );
    }
  }
  
  export default App;
  
  // 子
  import React from "react";
  
  function Home(props) {
    const { msg, getData } = props;
  
    const handleClick = () => {
      getData("子组件数据");
    };
  
    return (
      <div>
        <p>{msg}</p>
        <button onClick={handleClick}>传递数据</button>
      </div>
    );
  }
  
  export default Home;
  
  ```

* context

* redux

兄弟组件通信：

* 第三方库events，原理是发布订阅
* 状态管理库，例如mobx，redux

组件设计：

* 状态提升，即组件的状态尽量放在父组件中，然后由父组件下发数据，这样形成一个可控的单向数据流

setState：

* 写法：
  * 对象形式
  * 函数形式

* 特点：

  * 不可变值
  * 可能是异步更新
  * 可能会被合并

* 不可变值

  * state不能直接修改，必须通过setState修改

* 可能异步更新

  * 由react控制，即在生命钩子中和合成事件中为异步

    * 在 `React`的生命周期和合成事件中， `React`仍然处于他的更新机制中，这时无论调用多少次 `setState`，都会不会立即执行更新，而是将要更新的·存入 `_pendingStateQueue`，将要更新的组件存入 `dirtyComponent`。
      当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 `didmount`后会将批处理标志设置为 `false`。这时将取出 `dirtyComponent`中的组件以及 `_pendingStateQueue`中的 `state`进行更新。这样就可以确保组件不会被重新渲染多次。 

  * 不是react控制，即在自定义dom事件和定时器中为同步

    * 当我们在异步代码中调用 `setState`时，根据 `JavaScript`的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，这时 `React`的批处理机制已经走完，处理标志设被设置为 `false`，这时再调用 `setState`即可立即执行更新，拿到更新后的结果。 
    
```js
    componentDidMount() {
        document.body.onClick = function() {
            // 同步
        }
        
        setTimeout(() => {
            // 同步
        },1000)
    }
```

* 可能会被合并
  * 对象形式：会合并
  * 函数形式：不会合并
* 最佳实践：建议使用异步，因为异步是为了性能优化

### 生命周期

单组件（fiber之前）：

* 初始化阶段

  * 构造函数
  * getDefaultProps，props默认值
  * getInitialState，state默认值

* 挂载阶段

  * componentWillMount
  * render
  * componentDidMount

* 更新阶段

  props：

  * componentWillReceiveProps
  * shouldComponentUpdate
  * componentWillUpdate
  * render
  * componentDidUpdate

  state：

  * shouldComponentUpdate
  * componentWillUpdate
  * render
  * componentDidUpdate

* 卸载阶段

  * componentWillUnmount

单组件（fiber之后）：

* 挂载阶段：

  * 构造函数
  * `static getDerivedStateFromProps(props,state)`

  * render
  * componentDidMount
* 更新阶段

  * `static getDerivedStateFromProps(props,state)`
  * shouldComponentUpdate
  * render
  * `getSnapshotBeforeUpdate(prevProps,prevState)`
  * componentDidUpdate
* 卸载阶段

  * componentWillUnmount
* 错误处理：
  * componentDidCatch

父子组件：

* 和vue组件一致

注意：

* fiber开启了异步渲染，所以render之前的生命周期函数可能会执行多次，所以废弃了带有will的生命周期钩子。注意：16版本并没有删除只是废弃， 但是不能和新增的钩子函数混用 ，倒了17版本才会删除
* 新增了错误捕获相关的生命周期钩子，即getDerivedStateFromError和ComponentdidCatch

数据请求：

* 放在componentDidMount中，不要放在componentWillMount中

  原因：

  * 服务器渲染，componentWillMount会执行两次
  * fiber架构中，componentWillMount可能执行多次，所以被废弃

### 内容分发

类似于vue的slot。

```js
import React, { Component } from "react";
import Home from "./Home";

class App extends Component {
  state = {
    msg: "父组件数据"
  };

  render() {
    return (
      <div>
        <Home>{this.state.msg}</Home>
      </div>
    );
  }
}

export default App;

// 子
import React from "react";

function Home(props) {
  return <div>{props.children}</div>;
}

export default Home;
```

### protals

概念：

* 默认父组件嵌套渲染子组件

* 有些场景需要子组件渲染在父组件之外的层级，此时可以使用protals

  ```jsx
  import React, { Component } from "react";
  import Home from "./Home";
  
  class App extends Component {
    state = {
      msg: "父组件数据"
    };
  
    render() {
      return (
        <div>
          <Home>{this.state.msg}</Home>
        </div>
      );
    }
  }
  
  export default App;
  
  // 子
  import React from "react";
  import ReactDOM from "react-dom";
  
  function Home(props) {
    return ReactDOM.createPortal(<div>{props.children}</div>, document.body);
  }
  
  export default Home;
  ```

* 应用场景
  * 父组件overflow:hidden，子组件需要渲染出来
  * 父组件z-index太小，子组件需要渲染出来

### context

用于解决跨级组件之间数据通信。

```jsx
import React, { Component, createContext } from "react";

const context = createContext();
class App extends Component {
  state = {
    theme: "dark"
  };

  changeTheme = () => {
    this.setState({
      theme: this.state.theme === "dark" ? "light" : "dark"
    });
  };

  render() {
    return (
      <context.Provider value={this.state.theme}>
        <Home />
        <List />
        <button onClick={this.changeTheme}>修改主题</button>
      </context.Provider>
    );
  }
}

class Home extends Component {
  static contextType = context;

  render() {
    return <div>{this.context}</div>;
  }
}
// 或者写成
// Home.contextType = context

const List = () => {
  return <context.Consumer>{val => <p>{val}</p>}</context.Consumer>;
};

export default App;
```

### 错误边界

基本概念：

* 可以捕获并打印在其子组件树任何位置的JS错误，并且渲染出备用UI

无法捕获：

* 事件处理
* 异步代码，例如定时器
* 服务器端渲染
* 自身抛出的错误，而非子组件

作用：

* 回退ui
* 记录错误

生命周期：

* getDerivedStateFromError
* componentDidCatch

### 异步组件

基本用法：

* lazy
* suspense

```jsx
import React, { Component, lazy, Suspense } from "react";

const Home = lazy(() => import("./Home"));

class App extends Component {
  render() {
    return (
      <div>
        <div>App Page</div>
        <Suspense fallback={<div>loading</div>}>
          <Home />
        </Suspense>
      </div>
    );
  }
}

export default App;
```

缺点：

* 不支持服务器端渲染，需要使用第三方库react-loadable

### refs

* 可以获取dom或者组件实例
* createRef可以简化使用
* 不能再函数组件中使用ref属性
* 若想获取组件内部dom，需要使用ref转发

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}

// 或者
class UserForm extends Component {
  handleSubmit = () => {
    console.log("Input Value is: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} /> // Access DOM input in handle submit
        <button type='submit'>Submit</button>
      </form>
    )
  }
}

// 或者使用useRef
```

应用场景：

* 和dom库结合
* 一些js动画需要操作dom
* 像一些多媒体文件，需要操作dom

### 动画

需要使用react-transition-group库。

### css解决方案

* style：作用当前组件
* .css：作用全局
* [name].module.css：模块化解决方案
* styled-components：css-in-js解决方案

### scu

特点：

* SUC默认返回true，即React默认重新渲染所有子组件
* 可先不用SCU，有性能问题时再考虑使用

浅比较：

* 分类：
  * 类组件：PureComponent
  * 函数组件：memo
* 区别和联系
  * 都是浅层比较
  * memo只进行了props的比较，而PureComponent还进行了state的比较
  * memo不会比对hooks中使用的state

深层比较：

* 你可以手动调用shouldComponentUpdate来深层比较进行性能优化
* 不建议，递归的性能消耗非常大。所以推荐使用浅层比较，不可变数据immutable

注意：

* 不建议自己去进行深度比较，耗费性能

源码：

```jsx
function shallowEqual (objA: mixed, objB: mixed): boolean {
  // 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理
  // 第一关：基础数据类型直接比较出结果
  if (is (objA, objB)) {
    return true;
  }
  // 第二关：只要有一个不是对象数据类型就返回 false
  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  // 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量
  const keysA = Object.keys (objA);
  const keysB = Object.keys (objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // 第四关：比较两者的属性是否相等，值是否相等
  for (let i = 0; i < keysA.length; i++) {
    if (
      !hasOwnProperty.call (objB, keysA [i]) ||
      !is (objA [keysA [i]], objB [keysA [i]])
    ) {
      return false;
    }
  }

  return true;
}
```

### immutable.js

原因：

* 为了尽可能减少不必要的组件渲染，react推荐使用不可变值

原理：

* 基于共享数据（不是深拷贝），性能好

缺点：

* 学习成本

### 逻辑抽离

* mixin（废弃）

* 高阶组件

  ```jsx
  const HOCFactory = Component => {
      class HOC extends React.Component {
          // 公共逻辑...
          render() {
              // 透传所有props
              return <Component {...this.props} />
          }
      }
      return HOC
  }
  ```

  缺点：

  * 嵌套地狱，不利于调试

  特点：

  * 控制权在新生成的组件

* render props

  ```jsx
  import Cat from 'components/cat'
  class DataProvider extends React.Component {
    constructor(props) {
      super(props);
      this.state = { target: 'Zac' };
    }
  
    render() {
      return (
        <div>
          {this.props.render(this.state)}
        </div>
      )
    }
  }
  
  <DataProvider render={data => (
    <Cat target={data.target} />
  )}/>
  
  <!-- 简写后 -->
  
  <DataProvider>
    {data => (
      <Cat target={data.target} />
    )}
  </DataProvider>
  ```

  特点：

  * 渲染权在子组件

* hooks

  优点：

  * 解耦，代码简洁易维护
  * 函数友好，没有this
  * 易于维护，没有声明周期中散乱的逻辑代码

  缺点：

  * 写法限制

### hooks

基本概念：

* hook是一个特殊的函数，允许你在不编写class的情况下使用state和其它特性，例如某些生命周期函数

本质：

* 一个特殊的函数，允许你使用react特性，例如useState允许你使用state

原因：

* 逻辑复用，render props和hoc未能完美解决逻辑复用问题
* 类组件逻辑散乱，生命周期中包含互不相关的业务逻辑
* 尽量使用函数组件
* 类组件存在this问题

写法限制：有对应linter插件规范

* 不要在循环，条件或嵌套函数中调用hook
* 确保在函数组件的最顶层调用

常见hooks函数：

* useState

  * 初始值
    * 值的形式
    * 函数形式，当初始值不确定的时候需要使用函数形式，例如初始值依赖传入的props

  * setState区别：

    * 不会合并，useState直接将新状态替换老状态，如果需要替换需要这样写：

      ```jsx
      setInfo({
          ...info,
          name: 'ugu'
      })
      ```

    *  如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数当做参数传递给 setState。该回调函数将接收先前的 state，并返回一个更新后的值

      ```js
      const add = () => {
          setCount(count => count + 1)
      }
      ```

* useEffect
  * 第一次渲染的调用相当于`componentDidMount`
  * 之后的渲染的调用相当于`componentDidUpdate`
  * 当返回一个回调函数相当于`componentWillUnmount`
  
  使用方式：
  
  * 不写依赖，即省略第二个参数就是每次渲染都会执行
  * 使用[]，表示只执行一次
  
  注意：
  
  * 每次重新渲染都会执行一次useEffect可能会带来性能问题，因此你可以传入一个依赖来跳过effect来进行优化
  
  *  useEffect 里面使用到的state的值, 固定在了useEffect内部， 不会被改变，除非useEffect刷新，重新固定state的值 
  
    ```jsx
    const [count, setCount] = useState(0)
    useEffect(() => {
        console.log('use effect...',count)
        const timer = setInterval(() => {
            // 每次打印都是0
            console.log('timer...count:', count)
            setCount(count + 1)
        }, 1000)
        return ()=> clearInterval(timer)
    },[])
    ```
  
  *  useEffect不能被判断包裹 
  
  * useEffect不能被return打断
  
    ```jsx
    return ...
    useEffect(() => {})
    ```
  
  * useEffect接收的函数不能是async函数，因为它要么接收一个能清除副作用的函数，要么就不返回任何内容，而async返回的是promise
  
* useRef

  *  作为this , 可以存放任何变量，很好的解决闭包带来的不方便性。 
  * 操作dom

* useMemo
  
  ```jsx
  const Child = memo(({data}) =>{
      console.log('child render...', data.name)
      return (
          <div>
              <div>child</div>
              <div>{data.name}</div>
          </div>
      );
  })
  
  const Hook =()=>{
      console.log('Hook render...')
      const [count, setCount] = useState(0)
      const [name, setName] = useState('rose')
  
      const data = {
          name
      }
  
      return(
          <div>
              <div>
                  {count}
              </div>
              <button onClick={()=>setCount(count+1)}>update count </button>
              <Child data={data}/>
          </div>
      )
  }
  ```
  
  上述代码 点击按钮更新count的时候，Effect组件会render，一旦render，data就会重新生成，引用地址改变， 那么就算带着memo的Child组件，也会跟着重新render， 尽管最后其实Child使用到的值没有改变。这样就多余render了，于是需要使用useMemo缓存值引用。
  
  ```jsx
  const Child = memo(({data}) =>{
      console.log('child render...', data.name)
      return (
          <div>
              <div>child</div>
              <div>{data.name}</div>
          </div>
      );
  })
  
  const Hook =()=>{
      console.log('Hook render...')
      const [count, setCount] = useState(0)
      const [name, setName] = useState('rose')
  	
      // name如果不变就不会生成 新的data引用，这样子组件就不会重新render
     const data = useMemo(()=>{
          return {
              name
          }
      },[name])
      
      return(
          <div>
              <div>
                  {count}
              </div>
              <button onClick={()=>setCount(count+1)}>update count </button>
              <Child data={data}/>
          </div>
      )
  
  ```
  
  * memo是函数组件的pureComponent，用来保证组件不重新渲染，它的作用是实现整个组件的Pure功能。比较方式也是浅层比较。意思是，对象只比较内存地址，只要你内存地址没变，管你对象里面的值千变万化都不会触发render 
  * useMemo是用来在某些情况下不希望组件对所有 `props` 做浅比较，只想实现局部 `Pure` 功能，即只想对特定的 `props` 做比较，并决定是否局部更新。 
  
  使用注意：
  
  * 不要过渡依赖useMemo，因为useMemo本身也有开销。`useMemo` 会「记住」一些值，同时在后续 render 时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源。因此，过度使用 `useMemo` 可能会影响程序的性能。
  * **传递给 `useMemo` 的函数开销大不大？** 有些计算开销很大，我们就需要「记住」它的返回值，避免每次 render 都去重新计算。如果你执行的操作开销不大，那么就不需要记住返回值。否则，使用 `useMemo` 本身的开销就可能超过重新计算这个值的开销。因此，对于一些简单的 JS 运算来说，我们不需要使用 `useMemo` 来「记住」它的返回值。
  
* useCallback
  
  *  `useMemo` 和 `useCallback` 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 `useMemo` 返回的是函数运行的结果， `useCallback` 返回的是函数。 
  
  * useCallBack用来缓存函数来做性能优化，useMemo用来缓存值
  
* useReducer

  * 复杂的数据类型，需要差量更新
  * 可以获取到上一次的数据
  * 性能优化，稳定的dispatch句柄

  ```jsx
  import * as React from "react";
  
  interface ActionType {
    type: string | undefined;
  }
  
  const reducer = (state = 0, action: ActionType) => {
    const { type } = action;
    switch (type) {
      case "add":
        return state + 1;
      case "reduce":
        return state - 1;
      default:
        break;
    }
  };
  
  const App = () => {
    const [count, dispatch] = React.useReducer(reducer, 0);
  
    return (
      <div>
        <p>{count}</p>
        <button onClick={() => dispatch({ type: "add" })}>+1</button>
        <button onClick={() => dispatch({ type: "reduce" })}>-1</button>
      </div>
    );
  };
  
  export default App;
  ```

* useContext

  * 相当于 class 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`。 

  结合useReducer可以实现一个简化版的redux。

  ```jsx
  import * as React from "react";
  
  interface ActionType {
    type: string | undefined;
  }
  
  const reducer = (state = 0, action: ActionType) => {
    const { type } = action;
  
    switch (type) {
      case "add":
        return state + 1;
      case "delete":
        return state - 1;
      default:
        return state;
    }
  };
  const Context = React.createContext<any>(null);
  
  const Child = () => {
    const [count, dispatch] = React.useContext(Context);
    return (
      <div>
        <div>child...{count}</div>
        <button onClick={() => dispatch({ type: "add" })}>child add</button>
        <button onClick={() => dispatch({ type: "delete" })}>child delete</button>
      </div>
    );
  };
  
  const App = () => {
    const [count, dispatch] = React.useReducer(reducer, 10);
    return (
      <Context.Provider value={[count, dispatch]}>
        <div>
          <div>mom ... {count}</div>
          <Child />
          <button onClick={() => dispatch({ type: "add" })}>mom add</button>
          <button onClick={() => dispatch({ type: "delete" })}>mom delete</button>
        </div>
      </Context.Provider>
    );
  };
  
  export default App;
  ```

* useLayoutEffect

  ```jsx
  import React from 'react';
  
  const { useState, useLayoutEffect, useEffect } = React;
  
  // https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect
  
  // 适用场景：
  // 1. 解决闪烁问题
  
  function Child1() {
    const [value, setValue] = useState(0);
  
    // 异步更新会出现闪烁
    useEffect(() => {
      if (value === 0) {
        setValue(10 + Math.random() * 200);
      }
    }, [value]);
  
    console.log('render', value);
  
    return (
      <div>
        {value === 0 ? <h1>xiixix</h1> : <h4>value: {value}</h4>}
        <button onClick={() => setValue(0)}>click me</button>
      </div>
    );
  }
  
  function Child2() {
    const [value, setValue] = useState(0);
  
    // 同步更新将不会出现闪烁
    useLayoutEffect(() => {
      if (value === 0) {
        setValue(10 + Math.random() * 200);
      }
    }, [value]);
  
    console.log('render', value);
  
    return (
      <div>
        {value === 0 ? <h1>xiixix</h1> : <h4>value: {value}</h4>}
        <button onClick={() => setValue(0)}>click me</button>
      </div>
    );
  }
  export default function UseLayoutEffect() {
    return (
      <div>
        <Child1 />
        <hr />
        <hr />
        <Child2 />
      </div>
    );
  }
  ```

* useImpreativeHandle

  ```jsx
  import React from 'react';
  const { useRef, useImperativeHandle, forwardRef } = React;
  
  // https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle
  // 适用场景: ref 转发时候代理一层，做 API 的上层封装
  
  interface IChildRef {
    getHeight(): number;
  }
  
  const Child = forwardRef((props: {}, ref: React.Ref<IChildRef>) => {
    const divRef = useRef<HTMLDivElement>(null);
  
    useImperativeHandle(ref, () => ({
      getHeight: () => {
        console.log('计算了高度');
        return divRef.current?.clientHeight || 0;
      }
    }));
  
    return (
      <div ref={divRef} style={{ height: '100px', width: '100px', border: '1px solid #000' }}>
        i am child
      </div>
    );
  });
  
  export default function UseImperativeHandle() {
    const childRef = useRef<IChildRef>(null);
  
    function getChildHeight() {
      console.log(childRef.current?.getHeight());
    }
  
    return (
      <div>
        useImperativeHandle Demo
        <Child ref={childRef} />
        <button onClick={getChildHeight}>click me</button>
      </div>
    );
  }
  ```

* useLayoutEffect

  * useLayout在浏览器layout，painting之前执行；useEffect在dom渲染完成后执行
  *  其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后**同步**调用 effect 
  * **可以使用它来读取 DOM 布局并同步触发重渲染**
  * 在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被**同步**刷新
  * **尽可能使用标准的 useEffect 以避免阻塞视图更新**

* 自定义hooks

  * 只能use开头

  ```jsx
  
  ```

### redux

基本概念：

* store state
* action
* reducer

三大原则：

* 单一数据源：只有一个store实例，所有数据都存储在里面
* state只读：不能直接修改，而是通过特定的方法修改
* reducer必须是纯函数，函数的返回值依赖参数

单向数据流：

* 组件dispatch(action)
* reducer处理type相关的action，并返回新的state
* 组件subscribe数据变化，更新view

react-redux：

* 基本概念
  * `<Provider>`
  * connnect
  * mapStateToProps和mapDispatchToProps

* 作用
  * 简化redux的使用，无需手动订阅state的改变

异步操作：

* 可以直接通过componentDidMount中直接操作，操作后再进行操作redux
* 使用中间件

中间件：

* 常见中间件
  * redux-thunk
    * 优点：简单，体积小
    * 缺点：耦合，异步操作和action耦合在一起
  * redux-saga
    * 优点：异步解耦，功能强大
  * redux-devtools
  * redux-logger

* 原理：对dispatch的封装

  ```js
  let next = store.dispatch
  
  store.dispatch = function(action) {
      // 插入逻辑
      next(action)
  }
  ```

优点：

* 可追溯的状态管理
* 可维护性
* 使得代码更加纯粹和独立，易于测试

hooks：

* useReducer，useContext可以替代redux的部分功能

注意：

* 自己绘制redux流程图

### react-router

路由模式：

* hash
* history

路由传参：

* query
* param

路由跳转：

* 声明式：link标签

* 编程式

  ```jsx
  const history = useHistory()
  history.push('/')
  ```

路由懒加载：

```jsx
import {Browser Router as Router,Route,Switch} from 'react-router-dom'
import React,{Suspense,lazy} from 'react'

const Home = lazy(() => import('./routes/Home'))
const About = lazy(() => import('./routes/About'))

const App = () => {
    <Router>
        <Suspense fallback={<div>loading</div>}>
            <Switch>
            	 <Route exact path="/" component={Home} />
            	 <Route exact path="/about" component={About} />
            </Switch>
        </Suspense>
    </Router>
}
```

### 原理

函数式编程：

* 纯函数
  *  纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果
* 不可变值

组件渲染和更新过程：

* 渲染过程：
  * render函数返回的jsx编译生成vnode
  * patch(elm,vnode)生成dom结构

* 更新过程：
  * 调用setState修改数据
  * render生成newVNode
  * patch(vnode,newVNode)生成新的dom结构
    * reconciliation阶段，执行diff算法，属于纯JS计算
    * commit，将diff结果渲染到真实DOM中

jsx本质：

* 原理：编译生成createElement函数，执行该函数生成vnode

虚拟dom：

* 优点：
  * 使得跨端得以实现
  * 性能优越
  
* 缺点：
  * 运行时性能消耗，diff算法
  * 无法做到极致优化
  
* 具体模拟过程：

  ```js
  var element = {
    tagName: 'ul', 
    props: { 
      id: 'list'
    },
    children: [ 
      {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
      {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
      {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
    ]
  }
  ```

dom diff：

* 时间复杂度：
  * 优化前：循环递归diff算法，算法的复杂度O(n^3)
  * 优化后：O(n)

* 三个设计思想：
  * 永远只比较同层节点，因为跨级操作很少，例如：将子节点移动到父节点这一层级
  * 不同tag或class的两个节点生成不同的树
  * 通过key值来区分元素是否相同

* 优化diff算法：
* tree diff：
    * dom tree只进行同级比较，如果比较的节点不存在了，那么该节点和其子节点会直接删除，不需要对子节点重新比较。优点是只需要遍历一遍树就可以比较完毕。
* component diff：
    * 组件类型相同时，可以通过SCU判断当前组件是否需要更新，这样可以节省时间
    * 组件类型不同时，则将该组件判断为dirty component，直接替换该组件以及组件下的所有子节点，不需要再对其子节点进行比对
* element diff
    * 同一层级的子节点可以通过key来区分，这样就仅仅是移动子节点的位置，而不是删除并重新创建子节点
  * key不建议使用index，因为数组的index值不稳定，例如数组的splice操作会导致index发生变化，从而提高diff消耗

fiber架构：

`React 16`又称`React Fiber`。至于为什么有`fiber`架构，是因为之前组件的更新过程是同步的，这个过程可能会进行生命周期调用，比对DOM树以及更新DOM树一些纯CPU计算。如果有多个组件同时需要更新，此时浏览器主线程就会一直执行更新操作，无法响应类似于用户操作这种更高级别的任务。由于只能等到更新完成后，才会响应用户操作，在用户看来就是界面卡顿现象，用户体验很差。

而在`Fiber`架构中，会将一个更新过程进行多个分片操作，这样就很小的分片更新操作就可能被优先级高的任务打断，从而实现异步更新。

根据React Fiber的设计，一个组件的渲染被分为两个阶段：第一个阶段（也叫做render阶段）是可以被React打断的，一旦被打断，这阶段所做的事情将会被废弃，当处理好优先级更高的任务后，再重新渲染这个组件，所以这个阶段可能会多次执行；第二个阶段叫做commit阶段，一旦开始就不能中断，也就是说这个阶段会一直持续到渲染结束。

开启异步渲染，虽然获得了更好的感知性能，但是第一阶段的生命周期函数可能会被执行多次，所以不得不废弃一些render阶段之前回调函数，包括这些：

* componentWillReceiveProps
* componentWillUpdate
* componentWillMount

那么在第一阶段就只有下面生命周期函数了：

* 构造函数
* getDerivedStateFromProps(纯函数)
* shouldComponentUpdate(纯函数)

所以，你不应该再第一阶段生命周期函数中执行有副作用的代码，例如不要在componentWillMount中发送请求，而是在componentDidMount中发送请求。

hooks：

* 复用和记录原理：
  *  初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中
  * 更新的时候，按照顺序，从数组中把上次记录的值取出
  * react原生是通过链表而不是数组来实现hooks

* 只能函数外层调用hook，不能在循环或者条件语句中调用
  * 数组是按照hook定义的顺序来放置数据，如果hook顺序变化，那么数组不会感知到

### 优缺点

优点：

* 组件化开发，便于迭代维护
* 虚拟dom，性能优异
* 生态很好

缺点：

* 学习成本高，对新手不太友好

## webpack

### 基本概念

webpack是一款打包工具，将js，json，css和图片等文件根据依赖关系打包成静态资源。

```js
module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
    	path: require('path').resolve(__dirname, 'dist'),
        filename: 'dist.js'
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                loader: 'vue-loader'
            }
        ]
    },
    plugins: [
        new HtmlWebpakPlugin()
    ]
}
```

为什么要打包？

* 例如一个页面依赖三个脚本，就需要发三次http请求，而通过打包工具可以根据依赖关系将其打包成一个文件，减少http请求
* 打包工具通过plugin可以增强其能力，做一些构建工具能做的事情。例如：资源压缩，热更新，自动部署等工程化操作

### loader

概念：

* 可以让webpack拥有解析非js文件的能力

原理：

* loader本质是一个函数

手写：

```js
module.exports = function(source) {
    return source.replace('hello', 'h')
}
```

### plugin

概念：

* 可以丰富webpack的能力，例如做一些构建工具能做内容

原理：

* plugin本质是一个类，通过tapable提供的钩子在不同函数中做对应的处理

### 多页面打包

* 多入口
* 多出口

### 抽离压缩css

* 抽离css：mini-css-extract-plugin
* 压缩css：optimize-css-assets-webpack-plugin

### chunk

* module：开发时所写的模块，无论是用commonjs和es6方式书写的模块
* chunk：webpack根据文件引用打包模块时会生成chunk，webpack会对chunk进行一些处理

* bundle：webpack对chunk处理后，最终输出成浏览器可以直接运行的bundle文件

一般来说，一个chunk对应一个bundle，当然你也可以分离chunk。例如：index.js模块内部引入了index.css，此时会根据依赖关系打包成一个chunk，并最终生成一个bundle。但是，你也可以通过插件从chunk中抽离出一个bundle.css。

一句话总结，module，chunk和bundle就是同一份逻辑代码在webpack处理前后的不同名称。

注意：可以画图理解

### filename和chunkFilename

* filename：对应entry里面的输入文件名称，表示webpack输出后的文件名
* chunkFilename：表示打包出来的chunk文件名称，默认是chunk的id，一般为数字命名，当然也可以通过魔法注释webpackChunkName来改变chunkFilename。常常应用在异步加载的chunk文件

### prefetch和preload

* prefetch：预拉取会在浏览器闲置下载文件。例如异步组件会在点击按钮时才会动态生成一个script标签并添加到head中，而设置预加载可以以`<link rel='prefetch' as="script">`的形式预先拉取代码

  ```js
  import(/*webpackPrefetch: true*/ 'lodash')
  ```

* preload：预加载会在父chunk加载时并行下载文件

区别：

* preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。
* preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
* preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻

### hash,chunkhash和contenthash

背景：

* hash一般是结合cdn缓存来使用的。如果文件内容改变的话，那么对应的文件哈希值就会改变，对应的html引用的url地址也会改变，触发cdn服务器从源服务器上拉去对应数据，更新本地缓存

区别和联系：

* hash：表示与整个项目的构建有关，例如文件改变了，那么重新构建就会有新的hash
* chunkhash：重新构建后hash改变会带来一个问题，例如util.js的代码并没有发生改变，但是hash改变导致缓存失效。而chunkHash就是解决这个问题，你可以配置不同的入口文件依赖，webpack根据不同的入口文件进行依赖文件解析，构建对应的 chunk，生成对应的哈希值。只要文件不改变，就不会重新生成新的hash
* contentHash：例如index.js和index.css同属于一个chunk，那么如果仅仅是index.js改变，那么打包后它们的hash都发生变化，对于css文件你就无法使用缓存。而contentHash可以根据资源内容创建唯一hash，也就是说文件内容不变，hash不变

简单来说：

* hash计算与整个项目构建有关
* chunkHash计算与chunk有关
* contentHash计算与文件内容有关

### 原理

* fs模块读取入口文件内容，生成ast
* 通过ast抽离依赖模块，生成依赖关系图
* 根据生成的依赖关系图生成对应环境能执行的代码，也就是生成bundle.js

### 构建优化

* 保证node和webpack版本为最新
* loader尽可能少的应用到模块上
* loader和plugin都有启动时间，尽量少用不同的工具
* 加快文件解析速度，例如尽量减少resolve.extensions的数量
*  使用 `DllPlugin` 将更改不频繁的代码进行单独编译 
* 明确没有依赖的模块开启noParse
* 如果文件以cdn的方式引入到html中，可以开启ignore plugin来忽略该模块打包
* happyPack多线程打包
* webpack-bundle-analyzer分析打包结果
* 分离环境，也就是说避免在开发环境使用生产环境的工具，例如Uglifyjsplugin

* 合理的使用sourceMap
* 使用tree shaking剔除多余代码

### 优化前端代码

* 压缩代码
* cdn加速
* tree shaking
* 代码分割，提取公共模块

### 代码分割

基本概念：

* 使用splitChunks

优点：

* 公共部分缓存
* 提高页面加载速度，一般来说，加载两个小chunk，比一个大chunk要高

### hmr

基本概念：

* 允许在运行时更新各种模块，并且不需要完全刷新浏览器

开启：

* 通过配置devServer的hot属性

其它框架：

* React Hot Loader：实时调整react组件
* Vue Loader：支持vue组件的HMR

### tree shaking

开启条件：

* es6模块，因为是静态导入
* package.json要有sideEffects定义
*  引入一个能够删除未引用代码(dead code)的压缩工具(minifier) ，例如UglifyJSPlugin

### source map

* source-map：大而全，所以构建时间最长
* cheap-module-eval-source-map：dev环境推荐使用，出错提醒和构建速度有一个平衡
* cheap-module-source-map：prod环境推荐使用

## babel

基本概念：

* babel是一个js编译器，允许你使用es6书写代码

原理：

* ast

组成：

* @babel/core：ast转换的核心
* @babel/cli：cli工具
* @babel/preset-env：无需一个个导入插件转换代码，presets是一组预设好的插件集合
* @babel/plugin：以插件的形式转换代码
* @babel/runtime
* @babel/polyfill
* .babelrc/babel.config.js

@babel/preset-env：

* babel会把javascript语法分为api和syntax，像箭头函数，class这种语法是可以被转换的。而includes，Promise这些api是无法被转换的，因此需要@babel/polyfill来提供对api的支持

@babel/polyfill：

*  @babel/polyfill由core-js2和regenerator-runtime组成，后者是facebook开源库，用来实现对generator、async函数等的支持，前者是js标准库，包含不同版本javascipt语法的实现

* 整体引入@babel/polyfill体积太大，你可以通过配置useBuiltins来按需引入

* 注意：babel7.4不支持core-js2到core-js3的平滑过渡，所以废弃了@babel/polyfill，所以你需要直接引入core-js3和regeneratore-runtime代替

  ```js
  import "@babel/polyfill";
  
  // migration
  
  import "core-js/stable";
  import "regenerator-runtime/runtime";
  ```

*  使用core-js3有很多优点，首先就是新，包含很多新特性，其次就是可以配合@babel/runtime

@babel-runtime：

* 上面编译出的代码存在两个问题：

  *  高阶语法向低阶语法转化时引入了了很多helper函数(如_classCallCheck)。当文件数量很多时，每个文件都引入这些helper函数会使得文件体积增大，怎么这些helper函数抽离到单独的模块，然后按需引入呢？ 
  *  虽然polyfill是按需引入的，但是会污染全局命名空间，当你写的是公共库时，可能会与使用者本地的方法产生冲突。例如你在你的库中引入了polyfill中的Promise，使用者自身定义了自己的Promise，这就容易产生冲突。如何将你的公共库中引入的polyfill api隔离起来呢？ 

  需要解决这两个问题，就需要使用@babel/runtime和@babel/plugin-transform-runtime

*  @babel/runtime依赖@babel/helpers和regenerator-runtime，helper函数都可以从这里面引入，手动的肯定不可能，于是 babel 提供了 [`@babel/plugin-transform-runtime`](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/README.md) 来替我们做这些转换。 

*  解决第二个问题需要使用@babel/plugin-transform-runtime option中的corejs参数。默认为false，不对polyfill进行处理。可以设为不同版本的core-js，例如设置为3版本，完美解决问题。注意：设置为2版本还是有问题，例如includes方法还是不能用 

##  Node

### 架构

基于chrome v8的js运行环境，使用了事件驱动，非阻塞的IO模型。

* v8作为js引擎
* libuv提供跨平台能力，还有线程池，异步io等能力

非阻塞：

* 进程不等待IO完成，并通过事件通知主程序IO完成

异步IO

* 每个调用之间无需等待之前的IO调用是否完成

### 版本号

^aa.bb.cc：

* aa：大版本号，api改变
* bb：表示修复了较大的bug
* cc：表示细微修改
* ^：表示当前大版本号下面的最新版本
* ~：当前制定版本

### 内存

一般的后端语言，内存使用上是没有限制的，但是在Node中，由于v8的内存管理机制在浏览器的应用场景下绰绰有余，所以在node中，无法直接操作大内存对象。具体表现为：

* 64位系统：1.4GB
* 32位系统：0.7GB

即使你电脑的物理内存有32GB，都会有这个限制。

> buffer对象不是通过v8分配内存的。

### buffer

创建buffer：

* Buffer.alloc
* Buffer.allocUnsafe
* Buffer.from

buffer长度：

* buffer.length

### 文件流

```js
const rs = fs.createReadStream('./a.js')
const ws = fs.createWriteStream('./b.js')

rs.pipe(ws)
```

### 模块化

模块分类：

* 核心模块
* 第三方模块
* 自定义模块

require的过程：

* 路径分析
  * 当前目录的node_modules
  * 父级目录的node_modules
  * 根目录下的node_modules
* 文件定位
  * 若require不包含扩展名，会按js，json和node的顺序自动补全
  * 若发现是一个目录，则会解析目录下面的package.json的main字段，若没有，则默认是index.js，index.json和index.node

* 编译执行：这个过程会有缓存
  * js文件：通过fs模块同步读取文件
  * json文件：通过fs模块读取后，使用JSON.parse解析
  * node文件：是c++扩展

并不是所有模块都需要这三步，对于核心模块就不需要这三个过程。

核心模块：

* path
* url
* http
* querystring
* util
* fs

### 爬虫

* 使用robots.txt

* token
* 判断user-agent
* 判断referer
* 异步
* 限定单位时间内访问次数(nginx)
* 关键信息可以用图片

### 调试

* vs code断点
* dev tools
* 命令行，node --inspect

### 编码

base64：

* 是一种编码方式，不是加密手段
* 只能出现0-9，a-z，A-Z，+和/这64个字符

分类：

* ASCII
* GBK，GB2312
* Unicode
  * 面向传输的utf-8

### 高并发

* 增加机器数，通过负载均衡去分摊请求
* 提高机器性能，对于CPU密集型任务有效

缺点：

* 成本高

### 加密

使用crypto模块的hash算法进行加密，常见的有md5，sha1和sha256。

对称加密和非对称加密：

* 对称加密：只有一个密钥，加密和解密都是这个密钥
* 非对称加密：两个密钥，公钥和私钥

### mock数据

* postman
* easy-mock
* http proxy，例如devServer
* 静态服务器，例如public文件夹
* 抓包工具代理本地json文件

### RESTful

一种软件架构风格：

* 通过url定位资源
* 通过http动词描述资源

### 登录

http是无状态协议，所以需要一些方法判断用户：

* cookie+session
* jwt
* oauth

session和jwt的区别：

* session存储在服务端，jwt保存在客户端
* cookie不能跨域，jwt可以跨域
* session需要持久化，一般存储在数据库中，所以查询session会有一定性能消耗，但是相较于jwt也会安全一些

### express

 中间件：

```js
app.use((req, res, next) => {
    console.log('this is a middleware')
    next()
})
```

原理：异步任务串行执行

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 200);
});
const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(2);
  }, 300);
});

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(3);
  }, 100);
});
var arr = [promise1, promise2, promise3];

const fn = async function(arr) {
  for (let i = 0; i < arr.length; i++) {
    try {
      const result = await arr[i];
      console.log(result);
    } catch (error) {
      // handle error
    }
  }
};

fn(arr);
```

除了使用async/await之外，还下面方法实现异步任务串行执行：

* promise
* generator
* 第三方库
* ...

### koa

中间件：

```js
app.use(async (ctx, next) => {
    console.log(1)
    next()
    console.log(2)
})
```

原理：将中间件作为next函数的参数一直递归执行下去。

### ssr

ssr：

* 下载html
* 渲染页面

csr：

* 下载html文件
* 下载js文件
* 执行js文件
* 发送ajax请求
* 渲染页面

ssr优点：

* seo有好
* 更快的首屏加载速度

csr优点：

* 用户体验好，可以实现各种复交互的功能
* 前后端分离
* 减轻服务器压力
* 局部刷新

原理：

* 浏览器发送请求，服务器运行react和vue框架生成页面，然后返回生成的页面

  ```js
  const express = require('express')
  const Vue = require('vue')
  const app = express()
  
  const renderer = require('vue-server-render').createRenderer()
  
  const page = new Vue({
    data: {
      msg: 'hello world'
    },
    template: '<div>{{msg}}</div>'
  })
  
  app.get('/', async (req, res) => {
    const htmlString = await renderer.renderToString(page)
    res.send(htmlString)
  })
  
  app.listen(3000)
  ```

同构渲染：

* 区别于传统ssr，前后端通过模板耦合在一起，难以复用。同构渲染就是前端后端都使用js，尽量复用代码

  难点：

  * 数据处理，服务器没有dom和生命周期函数

  解决：

  * 脱水：服务器将数据挂载到window对象随着html文件一起传递给浏览器
  * 注水：浏览器直接拿脱水的数据来初始化组件渲染

## web安全

### xss

分类：

* 反射型

  * 首页直接显示用户名

    ```js
    http://www.baidu.com?name=<script>alert(1)</script>
    ```

* 存储型

  * 评论系统

* dom型

  * dom节点添加

    ```html
    <img onerror="alert(document.cookie)" />
    ```

危害：

* 流量劫持
* 窃取cookie

解决方法：

* 过滤部分标签，例如img，a，script等
* `<>`进行转义
* 设置http-only

总之永远不要相信用户输入。

### csrf

区别：

* xss：跨站脚本攻击，关注点是脚本，攻击者可以盗取用户身份攻击，原则上为所欲为，是用户太相信网站导致
* csrf：跨站请求伪造，关注点是伪造，攻击者借助用户的手去攻击，做的事有局限性，是网站太相信用户导致

解决：

* referer验证
* 验证码
* token验证
  * A网站生成一个随机token验证，返回给用户
  * 用户请求的时候带上token，服务器端设置一个拦截器去认证token，如果token不正确或者token没有，那么就认为是伪造的请求

### sql注入

原理：

* 拼接sql语句进行攻击

解决：

* 用户操作数据库权限限制
* 使用参数化的查询接口

### 重放攻击

原理：

* 相同的接口被原封不动的调用多次

防御：

* 加时间戳
* 加流水号
* 加随机数

### dos攻击

原理：

* 多台机器（肉鸡）模拟正常用户去请求目标服务器，占用服务器资源，导致正常用户无法访问

解决：

* 软件和硬件防火墙
* 扩容
* CDN

### 点击劫持

原理：

* 利用iframe标签的透明属性，诱骗用户点击被粉饰后的按钮

危害：

* 自动关注某个博客或者订阅用户

解决：

* 服务器端设置X-Frame-OPtions头，禁止页面在iframe中嵌入

## 设计模式

### 单例模式

```js
class Person {
    constructor() {}
}

Person.getInstance = (function() {
    let instance
    return function() {
        if(!instance) {
            instance = new Person()
        }
        return instance
    }
})()
```

应用场景：

* vuex多次use保证只安装一次

### 工厂模式

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(this.name);
  }
}

class Factory {
  static create(name) {
    return new Person(name);
  }
}

const xiaoming = Factory.create("xiaoming");
xiaoming.sayName();
```

### 策略模式

* 优化if-else

### 代理模式

```js
const info = {
  name: "ugu"
};

const newInfo = new Proxy(info, {
  set(target, key, vlaue) {
    target[key] = value;
      
    // return Reflect.set(target,key,value,receiver)
  },
  get(target, key) {
    return target[key];
    
    // return Reflect.get(target,key,value,receiver)
  }
});
```

### 发布订阅模式

```js
class EventEmitter {
  constructor() {
    this._events = {};
  }

  on(type, fn) {
    if (!this._events[type]) {
      this._events[type] = [];
    }

    this._events.push(fn);
  }

  emit(type) {
    if (this._events[type] && this._events[type].length) {
      this._events[type].forEach(fn => fn());
    }
  }
    
  off(type) {
      if(!type) {
          return 
      }
      
      delete this._events[type]
  }
}
```

### 观察者模式

```js
class Observer {
  constructor() {
    this.arr = []
  }

  attach(sub) {
    this.arr.push(sub)
  }

  setState(state) {
    this.arr.forEach(item => item.update(state))
  }
}

class Subject {
  constructor(name) {
    this.name = name
  }

  update(state) {
    console.log(`${this.name}监听到了${state}的变化`)
  }
} 
```

区别：

* 观察者模式基于发布订阅模式
* 观察者模式有耦合，发布订阅完全没有耦合

## 性能优化

### 网络优化

减少http请求次数：

* 图片
  * 懒加载
  * base64
  * webp格式
  * 雪碧图
  * iconfont或者css代替图标
* 缓存
* 避免重定向

减少http请求资源的大小

* gzip压缩
* 语法压缩：例如注释，空白符等

其它网络优化：

* cdn
* dns预解析
* 静态资源放在不同域名下面

### 渲染优化

渲染优化

* 使用weakSet和weakMap缓存dom
* 尽量使用合成器动画transition，不使用js动画
* dom操作单独作为一个图层
* 多次DOM操作使用fragment
* dom操作是可以display:none，操作结束后再显示，这样不经过render tree
* 事件委托
* 节流和防抖
* 减少回流和重绘
* css放在上面，js放在下面

### vue优化

* 合理使用v-if和v-show
* 合理使用computed
* 循环渲染的时候加key
* 自定义事件，dom事件以及定时器要及时销毁
* data层级不要太深，并且只存放与视图有关的数据
* 合理使用keep-alive
* 合理使用异步组件
* 尽量进行组件拆分
* 组件库按需加载
* 考虑将vue相关的库使用cdn的方式引入
* 路由懒加载

### react优化

* 尽量使用函数组件
* 使用shouldComponentUpdate
* 使用immutable
* react-redux只connect需要的组件
* 使用cra创建项目
* 保证key一致性
* 尽可能拆分组件

### 体验优化

* 骨架屏
* pwa

### seo优化

* 预渲染
* ssr

### node优化

* 升级node版本
* 计算密集型任务C++扩展
* 确保node_env是production
* 避免内存为缓存
* 压测node-clinic
* 搭建性能上报平台

## 工程化

### git

命令：

* git init

* git config
* git clone
* git remote
* git status
* git add
* git commit 
* git push
* git pull = git fetch + git merge
* git diff
* git branch
* git checkout
* git reset
* git log
* git rebase

冲突：

* fast-forward：直接将箭头指向最新提交
* 手动合并：例如master和dev分支都做了修改

fetch和pull：

* pull会拉取最新代码并合并
* fetch只是拉取，并不会自动merge

### postcss

概念：

* css种的Babel
* 不同于scss，less是css的预处理器，postcss是后处理器

功能：

* 语法检查：style linter
* 压缩语法：cssnano
* 兼容语法：autofixer
* 转换不支持的语法：cssnext
* ...

### 模块化

发展：

* 命名空间

* 自执行函数

* commonjs

* amd/cmd

* es6

* umd

  * 概念：一套代码可以运行在不同模块化规范中

  * 原理：能力检测

es6和commonjs模块化区别：

* 使用方式不一样
  * 前者import export
  * 后者require module.exports

* 前者可以导出多个值，后者只能导出一个
* 前者是静态语法，只能写在顶层，后者是动态的，可以写在判断语句中
* 前者的this是undefined，后者的this是当前模块

### typescript

优点：

* 直接编译成js，没有运行时开销
* 可以和js代码共存
* 遵循未来的规范
* 编译阶段检查类型错误，适合编写大型项目，便于维护

缺点：

* 有点复杂，对新手不友好，小项目不建议使用

了解程度：

* 基本的数据结构：js相关的数据结构，元组，枚举，接口，类，函数
* 元数据反射，类型注解，infer关键字等

泛型：

* 可以重用代码，例如一个函数接收一个类型，返回相同的类型，这样就不会将每个类型重新定义一遍

## 数据库

### mysql

优化：

* 使用合适的数据类型
* 尽量将列设置为Not null，因为null存储的列会占用更多空间
* 字段不宜过多
* 避免使用select *
* 明确只有一条数据返回，加上limit 1

外键：

* 两个关系的关联信息

主键：

* 一条记录的唯一标识，不能重复不能为空

### mongodb

* 关系型数据库和非关系型数据库有什么区别

## pwa

pwa全称Progressive Web App，即渐进式web应用。

* 首先是一个网页
* 通过相关技术实现native的功能，例如使用app manifest实现安装，使用service worker缓存实现离线，消息推送等

* 基于https，内容和传输安全

## 业务

### 瑞车安

### star

* 背景：公司需要做一个车辆运营管理，规范司机驾驶行为的一个平台，具体流程是通过在汽车上安装一个硬件，这个硬件主要做两件事——上传用户信息以及和司机交互。后端拿到这些信息再返回给前端，前端再实现对应的业务，例如监控等等。

* task：地图，监控相关的任务，当然还有一些规范文件上的业务，例如车辆信息，车辆管理，车队管理，区域管理等等模块

* action：

  * 在做开发的时候遇到一些困难，工时太短，需要熟悉angular的相关生态

  * 复杂的功能不知道如何实现，公司内部没有接触过直播，需要调研如何实现直播功能，并实现切换

  * 硬件不稳定，例如没有稳定测试硬件
  * 需要国家过审，因为涉及到隐私，所以规范文件硬盒，每个省的规范都不一样，并且某些功能必须实现，即使是假的功能

* result：
  * 按时完成了相关功能，并且在年底成功过检，收获了第一批用户
  * 并且在会展中心的时候斩获了智慧城市奖

### 推流

* ffmpeg
* 硬件推流，例如监控设备，obs

#### 推流服务器

* 开源解决方案，例如srs或者nginx-rtmp-server

* 后端自己实现直播流媒体服务器

* 第三方提供推流服务器服务

#### 直播协议

* rtmp：
  * 基于flash
  * 延迟性较低
* hls：
  * 苹果推出
  * 跨平台不好
  * 延迟较高
* http-flv：
  * 基于h5
  * 跨平台
  * 延迟较低

#### flvjs

原理：

* 音视频多通过flv承载
* 通过js解码获取的音视频数据
* 然后通过Media Source Extensions API将数据喂给Video标签播放

为什么不用mp4，明明video不支持flv，为啥绕圈子？

* 兼容目前的方案，多数据音视频服务采用flv容器格式传输音视频数据
* flv格式简单，mp4不容易解析

### lcrm app

#### 图片懒加载

真实图片地址放在自定义属性中，例如data-src，当图片滚动到可视区域内，再加载真实图片替换loading图片。

优点：减少服务器压力，提升用户体验

#### hybird

task：

* 背景：lcrm app是一个车辆管理平台
* tasks：我在其中负责了前端开发部分，例如vue搭建基础的开发框架，集成了项目开发需要的相关依赖，例如组件库，一些工具函数，项目中主要是负责首页，列表页，监控页面，车辆信息页面等
* 困难：
  * 公司没有混合开发经验，我们摸着石头过河
  * 中间遇到最大的困难就是移动端兼容性问题
* 成果：
  * 成功完成了项目，并比预期使用原生和安卓开发都快了半个月，提升了开发效率和人力成本

优点：

* 开发效率高
* 成本低
* 利用h5的繁华生态
* 热更新

缺点：

* 客户端和前端要协作开发
* 性能不如原生

通信：

* native调用h5：
  * 全局函数，例如window.sayMsg = function() {}
* h5调用native：
  * url
  * 通过addJavascriptInterface注册Android对象供H5调用，例如lcrm app获取登录信息

#### 真机调试

* 局域网，需要配置webpack的devServer
* chromewa
* vconsole

### 组件封装

* noticebar
* search
* list
* login
* register
* success
* fail
* ...

### 场景题

* 多维数组转换为一维数组

  ```js
  const arr = [1, [2, 3, [4, 5]]];
  
  function demo(arr) {
    while (arr.some(item => Array.isArray(item))) {
      arr = [].concat(...arr);
    }
    return arr;
  }
  ```

* js实现阶乘

  ```js
  function demo(n) {
      return n > 1 ? n * demo(n-1) : 1 
  }
  ```

* 队列

* 栈

* 排序

* 树

* 是否支持webp？

  * 可以手动发送一张webp图片格式请求，通过promise去封装
  * 手动创建的canvas，通过canvas的toDataURL看能否转换为webp格式的base64串
  * http的头信息accept中去判断